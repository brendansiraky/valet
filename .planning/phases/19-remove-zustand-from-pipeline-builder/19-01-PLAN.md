---
phase: 19-remove-zustand-from-pipeline-builder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/hooks/queries/use-pipeline-flow.ts
  - app/hooks/queries/use-pipelines.ts
autonomous: true

must_haves:
  truths:
    - "usePipelineFlow hook returns nodes and edges from React Query cache"
    - "onNodesChange updates cache immediately via setQueryData"
    - "onEdgesChange updates cache immediately via setQueryData"
    - "onConnect adds edge to cache immediately via setQueryData"
    - "Debounced save triggers after cache modifications"
  artifacts:
    - path: "app/hooks/queries/use-pipeline-flow.ts"
      provides: "Pipeline flow state management hook"
      exports: ["usePipelineFlow"]
      min_lines: 150
    - path: "app/hooks/queries/use-pipelines.ts"
      provides: "Pipeline types and FlowData interface"
      contains: "FlowData"
  key_links:
    - from: "app/hooks/queries/use-pipeline-flow.ts"
      to: "app/hooks/queries/use-pipelines.ts"
      via: "imports usePipeline, useSavePipeline"
      pattern: "import.*usePipeline.*use-pipelines"
    - from: "app/hooks/queries/use-pipeline-flow.ts"
      to: "@tanstack/react-query"
      via: "useQueryClient for setQueryData"
      pattern: "useQueryClient"
    - from: "app/hooks/queries/use-pipeline-flow.ts"
      to: "@xyflow/react"
      via: "applyNodeChanges, applyEdgeChanges, addEdge"
      pattern: "applyNodeChanges|applyEdgeChanges|addEdge"
---

<objective>
Create the `usePipelineFlow` hook that encapsulates React Query cache as the single source of truth for React Flow state.

Purpose: This hook is the foundation for the entire migration. It provides the same interface as the Zustand store but uses React Query's cache directly. Components will migrate to this hook in subsequent plans.

Output: A fully-typed hook that manages pipeline flow state through React Query with debounced autosave.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-remove-zustand-from-pipeline-builder/19-RESEARCH.md
@app/hooks/queries/use-pipelines.ts
@app/stores/pipeline-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FlowData type and update Pipeline interface</name>
  <files>app/hooks/queries/use-pipelines.ts</files>
  <action>
Update `use-pipelines.ts` to add proper typing for flow data:

1. Add `FlowData` interface:
```typescript
import type { Node, Edge } from "@xyflow/react";

export interface FlowData {
  nodes: Node[];
  edges: Edge[];
}
```

2. Update the `Pipeline` interface to use typed `flowData`:
```typescript
export interface Pipeline {
  id: string;
  name: string;
  description: string | null;
  flowData: FlowData;
}
```

3. Add node data types (moved from pipeline-store.ts):
```typescript
// Agent node data for React Flow nodes
export interface AgentNodeData {
  agentId: string;
  agentName: string;
  agentInstructions?: string;
  isOrphaned?: boolean;
  traitIds: string[];
  [key: string]: unknown; // Required for React Flow compatibility
}

// Trait node data for standalone trait nodes
export interface TraitNodeData {
  traitId: string;
  traitName: string;
  traitColor: string;
  [key: string]: unknown;
}

export type PipelineNodeData = AgentNodeData | TraitNodeData;
```

Keep all existing hooks (usePipelines, usePipeline, useRunPipeline, useSavePipeline, useDeletePipeline) unchanged.
  </action>
  <verify>Run `npm run typecheck` - should pass with no errors related to use-pipelines.ts</verify>
  <done>Pipeline and FlowData types are properly defined and exported from use-pipelines.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create usePipelineFlow hook</name>
  <files>app/hooks/queries/use-pipeline-flow.ts</files>
  <action>
Create new file `app/hooks/queries/use-pipeline-flow.ts` implementing the hook from 19-RESEARCH.md:

1. First, verify lodash-es is available or install it:
```bash
npm list lodash-es || npm install lodash-es && npm install -D @types/lodash-es
```

If lodash-es is NOT installed, install it first. The debounce function is needed for autosave.

2. Import dependencies:
```typescript
import { useCallback, useMemo, useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import {
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
  type Node,
  type Edge,
  type NodeChange,
  type EdgeChange,
  type Connection,
  type OnNodesChange,
  type OnEdgesChange,
  type OnConnect,
} from "@xyflow/react";
import debounce from "lodash-es/debounce";
import {
  usePipeline,
  useSavePipeline,
  type Pipeline,
  type FlowData,
  type AgentNodeData,
  type TraitNodeData,
  type PipelineNodeData,
} from "./use-pipelines";
```

3. Define return type interface:
```typescript
export interface UsePipelineFlowReturn {
  // Data (from cache)
  nodes: Node<PipelineNodeData>[];
  edges: Edge[];
  pipelineName: string;
  pipelineDescription: string;
  isLoading: boolean;

  // React Flow callbacks
  onNodesChange: OnNodesChange<Node<PipelineNodeData>>;
  onEdgesChange: OnEdgesChange;
  onConnect: OnConnect;

  // Actions
  updateName: (name: string) => void;
  updateDescription: (description: string) => void;
  addAgentNode: (
    agent: { id: string; name: string; instructions?: string },
    position: { x: number; y: number }
  ) => void;
  addTraitNode: (
    trait: { id: string; name: string; color: string },
    position: { x: number; y: number }
  ) => void;
  removeNode: (nodeId: string) => void;
  addTraitToNode: (nodeId: string, traitId: string) => void;
  removeTraitFromNode: (nodeId: string, traitId: string) => void;
  setNodesAndEdges: (nodes: Node<PipelineNodeData>[], edges: Edge[]) => void;
}
```

4. Implement the hook:
- Use `usePipeline(pipelineId)` for fetching
- Use `useQueryClient()` for cache manipulation
- Create `updateCache` helper that calls `setQueryData`
- Create debounced save function using `useMemo` + `lodash-es/debounce` with 1000ms delay
- Cleanup debounce on unmount via `useEffect` return
- Implement all callbacks using `updateCache` + `debouncedSave()`
- Extract flowData with proper type casting and defaults

5. Key implementation notes:
- NEVER mutate the `old` parameter in setQueryData - always return new objects
- Use React Flow's `applyNodeChanges`, `applyEdgeChanges`, `addEdge` utilities
- The hook's `useEffect` for cleanup is legitimate (cleanup pattern, not data sync)
- Use `staleTime: Infinity` is NOT needed here - React Query will not refetch while we're editing because we're actively using setQueryData

6. Export the hook and types.
  </action>
  <verify>Run `npm run typecheck` - should pass with no type errors. The hook is not used yet, so no runtime verification needed.</verify>
  <done>usePipelineFlow hook exists with full TypeScript typing, implements all required callbacks, properly manages React Query cache with debounced saves, and lodash-es dependency is installed</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. New file `app/hooks/queries/use-pipeline-flow.ts` exists and exports `usePipelineFlow`
3. `app/hooks/queries/use-pipelines.ts` exports `FlowData`, `AgentNodeData`, `TraitNodeData`, `PipelineNodeData`
4. lodash-es is listed in package.json dependencies
5. No changes to existing component behavior (hook is not used yet)
</verification>

<success_criteria>
1. usePipelineFlow hook is fully implemented and typed
2. Hook provides same interface as needed by current Zustand consumers
3. TypeScript compiles with zero errors
4. lodash-es dependency is installed and importable
5. No runtime regressions (components still use Zustand for now)
</success_criteria>

<output>
After completion, create `.planning/phases/19-remove-zustand-from-pipeline-builder/19-01-SUMMARY.md`
</output>
