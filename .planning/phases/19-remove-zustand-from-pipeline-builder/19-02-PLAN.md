---
phase: 19-remove-zustand-from-pipeline-builder
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - app/components/pipeline-builder/pipeline-tab-panel.tsx
  - app/components/pipeline-builder/pipeline-canvas.tsx
  - app/components/pipeline-builder/pipeline-context.tsx
autonomous: true

must_haves:
  truths:
    - "PipelineTabPanel reads pipeline data from usePipelineFlow, not Zustand"
    - "PipelineCanvas receives nodes/edges/callbacks as props from parent"
    - "Name changes update React Query cache and trigger debounced save"
    - "Node drag operations update React Query cache immediately"
    - "Edge connections update React Query cache immediately"
  artifacts:
    - path: "app/components/pipeline-builder/pipeline-tab-panel.tsx"
      provides: "Tab panel using React Query for state"
      contains: "usePipelineFlow"
    - path: "app/components/pipeline-builder/pipeline-canvas.tsx"
      provides: "Canvas receiving flow props"
      contains: "nodes.*edges.*onNodesChange"
    - path: "app/components/pipeline-builder/pipeline-context.tsx"
      provides: "Context for passing pipelineId to nested components"
      exports: ["PipelineContext", "usePipelineContext"]
  key_links:
    - from: "app/components/pipeline-builder/pipeline-tab-panel.tsx"
      to: "app/hooks/queries/use-pipeline-flow.ts"
      via: "imports usePipelineFlow"
      pattern: "import.*usePipelineFlow"
    - from: "app/components/pipeline-builder/pipeline-tab-panel.tsx"
      to: "app/components/pipeline-builder/pipeline-canvas.tsx"
      via: "passes nodes/edges/callbacks as props"
      pattern: "<PipelineCanvas.*nodes=.*edges="
---

<objective>
Migrate PipelineTabPanel and PipelineCanvas from Zustand to React Query by using the new usePipelineFlow hook.

Purpose: These are the main consumer components of pipeline state. Migrating them removes the primary dependency on pipeline-store.ts. The canvas becomes a pure presentational component that receives data via props.

Output: Both components work identically but now source data from React Query cache instead of Zustand.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-remove-zustand-from-pipeline-builder/19-RESEARCH.md
@.planning/phases/19-remove-zustand-from-pipeline-builder/19-01-SUMMARY.md
@app/components/pipeline-builder/pipeline-tab-panel.tsx
@app/components/pipeline-builder/pipeline-canvas.tsx
@app/hooks/queries/use-pipeline-flow.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PipelineContext for passing pipelineId to nested components</name>
  <files>app/components/pipeline-builder/pipeline-context.tsx</files>
  <action>
Create a new context file `app/components/pipeline-builder/pipeline-context.tsx`:

```typescript
import { createContext, useContext } from "react";

interface PipelineContextValue {
  pipelineId: string;
}

export const PipelineContext = createContext<PipelineContextValue | null>(null);

export function usePipelineContext(): PipelineContextValue {
  const context = useContext(PipelineContext);
  if (!context) {
    throw new Error("usePipelineContext must be used within PipelineContext.Provider");
  }
  return context;
}
```

This context will be used by agent-node.tsx (migrated in Plan 03) to access the pipelineId for trait operations without prop drilling.
  </action>
  <verify>Run `npm run typecheck` - should pass</verify>
  <done>PipelineContext exists and exports usePipelineContext hook</done>
</task>

<task type="auto">
  <name>Task 2: Migrate PipelineTabPanel to use usePipelineFlow</name>
  <files>app/components/pipeline-builder/pipeline-tab-panel.tsx</files>
  <action>
Rewrite PipelineTabPanel to use React Query instead of Zustand:

1. Remove imports:
```typescript
// REMOVE these:
import { usePipelineStore } from "~/stores/pipeline-store";
import type { AgentNodeData, PipelineNodeData } from "~/stores/pipeline-store";
```

2. Add imports:
```typescript
import { usePipelineFlow } from "~/hooks/queries/use-pipeline-flow";
import { PipelineContext } from "./pipeline-context";
import type { AgentNodeData, PipelineNodeData } from "~/hooks/queries/use-pipelines";
```

3. Replace the Zustand store usage with usePipelineFlow:
```typescript
// OLD:
const {
  getPipeline,
  loadPipeline,
  updatePipeline,
  addAgentNodeTo,
  addTraitNodeTo,
} = usePipelineStore();

// NEW:
const {
  nodes,
  edges,
  pipelineName,
  pipelineDescription,
  isLoading,
  onNodesChange,
  onEdgesChange,
  onConnect,
  updateName,
  addAgentNode,
  addTraitNode,
  setNodesAndEdges,
} = usePipelineFlow(pipelineId);
```

4. Remove the lazy initialization block (lines ~62-93 in current file). The hook handles this via React Query.

5. Update orphan detection to use nodes from hook instead of pipeline:
```typescript
const hasOrphanedAgents = useMemo(() => {
  const validAgentIds = new Set(agents.map((a) => a.id));
  return nodes.some((n) => {
    if (n.type !== "agent") return false;
    const agentData = n.data as AgentNodeData;
    return agentData.agentId && !validAgentIds.has(agentData.agentId);
  });
}, [nodes, agents]);
```

6. Update enriched nodes calculation for orphan status (do this on initial render):
```typescript
// Add useEffect for one-time orphan enrichment when initialData arrives
// This is a legitimate useEffect - it's reacting to external data arrival, not internal state sync
useEffect(() => {
  if (initialData && !isLoading) {
    const validAgentIds = new Set(agents.map((a) => a.id));
    const flowData = (initialData.flowData || { nodes: [], edges: [] }) as {
      nodes: Node<PipelineNodeData>[];
      edges: Edge[];
    };

    const enrichedNodes = flowData.nodes.map((node) => {
      if (node.type === "agent") {
        const agentData = node.data as AgentNodeData;
        return {
          ...node,
          data: { ...agentData, isOrphaned: !validAgentIds.has(agentData.agentId) },
        };
      }
      return node;
    });

    // Only set if different from current
    if (JSON.stringify(enrichedNodes) !== JSON.stringify(nodes)) {
      setNodesAndEdges(enrichedNodes, flowData.edges);
    }
  }
}, [initialData, agents, isLoading]); // Intentionally exclude nodes to avoid infinite loop
```

WAIT - this is an anti-pattern. Instead, handle orphan enrichment in the usePipelineFlow hook or compute it during render:

Better approach - compute isOrphaned during render (no useEffect):
```typescript
// Compute enriched nodes with orphan status during render
const enrichedNodes = useMemo(() => {
  const validAgentIds = new Set(agents.map((a) => a.id));
  return nodes.map((node) => {
    if (node.type === "agent") {
      const agentData = node.data as AgentNodeData;
      const isOrphaned = !validAgentIds.has(agentData.agentId);
      if (agentData.isOrphaned !== isOrphaned) {
        return {
          ...node,
          data: { ...agentData, isOrphaned },
        };
      }
    }
    return node;
  });
}, [nodes, agents]);
```

Then pass `enrichedNodes` to PipelineCanvas instead of `nodes`.

7. Remove the savePipeline callback - the hook handles debounced saves automatically.

8. Simplify handleNameChange:
```typescript
const handleNameChange = useCallback(
  (e: React.ChangeEvent<HTMLInputElement>) => {
    updateName(e.target.value);
    updateTabName(pipelineId, e.target.value);
  },
  [pipelineId, updateName, updateTabName]
);
```

9. Simplify handleDropAgent:
```typescript
const handleDropAgent = useCallback(
  (
    agentId: string,
    agentName: string,
    instructions: string | undefined,
    position: { x: number; y: number }
  ) => {
    addAgentNode({ id: agentId, name: agentName, instructions }, position);
  },
  [addAgentNode]
);
```

10. Simplify handleDropTrait similarly.

11. Update handleAutoLayout to use setNodesAndEdges:
```typescript
const handleAutoLayout = useCallback(() => {
  const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(
    enrichedNodes,
    edges
  );
  setNodesAndEdges(layoutedNodes, layoutedEdges);
}, [enrichedNodes, edges, setNodesAndEdges]);
```

12. Update PipelineCanvas props to pass data explicitly:
```typescript
<PipelineContext.Provider value={{ pipelineId }}>
  <PipelineCanvas
    nodes={enrichedNodes}
    edges={edges}
    onNodesChange={onNodesChange}
    onEdgesChange={onEdgesChange}
    onConnect={onConnect}
    onDropAgent={handleDropAgent}
    onDropTrait={handleDropTrait}
    isLocked={isLocked}
  />
</PipelineContext.Provider>
```

13. Update loading check:
```typescript
if (isLoading) {
  return <div className="flex-1 flex items-center justify-center">Loading...</div>;
}
```

14. Update Input value to use pipelineName from hook:
```typescript
<Input
  value={pipelineName}
  onChange={handleNameChange}
  ...
/>
```
  </action>
  <verify>Run `npm run typecheck` - may have errors until PipelineCanvas is updated</verify>
  <done>PipelineTabPanel uses usePipelineFlow hook, no longer imports from pipeline-store</done>
</task>

<task type="auto">
  <name>Task 3: Update PipelineCanvas to receive all data via props</name>
  <files>app/components/pipeline-builder/pipeline-canvas.tsx</files>
  <action>
Update PipelineCanvas to be a presentational component that receives data via props:

1. Remove imports:
```typescript
// REMOVE:
import { usePipelineStore } from "~/stores/pipeline-store";
import type { PipelineNodeData } from "~/stores/pipeline-store";
```

2. Add import:
```typescript
import type { PipelineNodeData } from "~/hooks/queries/use-pipelines";
import type { OnNodesChange, OnEdgesChange, OnConnect } from "@xyflow/react";
```

3. Update props interface:
```typescript
interface PipelineCanvasProps {
  nodes: Node<PipelineNodeData>[];
  edges: Edge[];
  onNodesChange: OnNodesChange<Node<PipelineNodeData>>;
  onEdgesChange: OnEdgesChange;
  onConnect: OnConnect;
  onDropAgent: (
    agentId: string,
    agentName: string,
    instructions: string | undefined,
    position: { x: number; y: number }
  ) => void;
  onDropTrait: (
    traitId: string,
    traitName: string,
    traitColor: string,
    position: { x: number; y: number }
  ) => void;
  isLocked?: boolean;
}
```

4. Remove pipelineId prop - no longer needed since canvas doesn't access store.

5. Remove all Zustand store usage - component now uses props directly:
```typescript
export function PipelineCanvas({
  nodes,
  edges,
  onNodesChange,
  onEdgesChange,
  onConnect,
  onDropAgent,
  onDropTrait,
  isLocked,
}: PipelineCanvasProps) {
  const { screenToFlowPosition } = useReactFlow();

  // Remove: const { getPipeline, createOnNodesChange, ... } = usePipelineStore();
  // Remove: const pipeline = getPipeline(pipelineId);
  // Remove: const onNodesChangeBase = useMemo(...);
  // Remove: const onEdgesChangeBase = useMemo(...);
  // Remove: const onConnectBase = useMemo(...);
  // Remove: wrapping callbacks (parent handles save now)
```

6. Update onDrop handler to use props:
```typescript
const onDrop = useCallback(
  (event: React.DragEvent) => {
    if (isLocked) return;
    event.preventDefault();

    const position = screenToFlowPosition({
      x: event.clientX,
      y: event.clientY,
    });

    const agentId = event.dataTransfer.getData("application/agent-id");
    if (agentId) {
      const agentName = event.dataTransfer.getData("application/agent-name");
      const agentInstructions = event.dataTransfer.getData("application/agent-instructions");
      onDropAgent(agentId, agentName, agentInstructions || undefined, position);
      return;
    }

    const traitId = event.dataTransfer.getData("application/trait-id");
    if (traitId) {
      const traitName = event.dataTransfer.getData("application/trait-name");
      const traitColor = event.dataTransfer.getData("application/trait-color");
      onDropTrait(traitId, traitName, traitColor, position);
    }
  },
  [isLocked, screenToFlowPosition, onDropAgent, onDropTrait]
);
```

7. Remove loading state check - parent handles this now. (Or keep a minimal one for safety)

8. Pass props directly to ReactFlow:
```typescript
return (
  <div className="h-full w-full">
    <ReactFlow
      nodes={nodes}
      edges={edges}
      nodeTypes={nodeTypes}
      onNodesChange={isLocked ? undefined : onNodesChange}
      onEdgesChange={isLocked ? undefined : onEdgesChange}
      onConnect={isLocked ? undefined : onConnect}
      onDragOver={onDragOver}
      onDrop={onDrop}
      fitView
      className="bg-muted/30"
      nodesDraggable={!isLocked}
      nodesConnectable={!isLocked}
      elementsSelectable={!isLocked}
      deleteKeyCode={isLocked ? null : "Backspace"}
    >
      <Background />
      <Controls />
      <MiniMap />
    </ReactFlow>
  </div>
);
```
  </action>
  <verify>Run `npm run typecheck && npm test` - should pass. Test the pipeline builder manually: open a pipeline, drag nodes, connect edges, edit name.</verify>
  <done>PipelineCanvas is a pure presentational component receiving all data via props, no Zustand dependency</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `npm test` passes (existing tests may need adjustment in Plan 04)
3. Manual testing:
   - Open a pipeline from list
   - Drag an agent to canvas - appears immediately
   - Move a node - persists after refresh
   - Connect two nodes - edge appears immediately
   - Edit pipeline name - updates in tab bar
   - Close and reopen tab - state is preserved
4. Neither component imports from `~/stores/pipeline-store`
</verification>

<success_criteria>
1. PipelineTabPanel uses usePipelineFlow hook exclusively
2. PipelineCanvas receives all state as props
3. All pipeline operations (drag, connect, edit) work correctly
4. Autosave works (changes persist after refresh)
5. Tab switching preserves state (via React Query cache)
6. No imports from pipeline-store in either component
</success_criteria>

<output>
After completion, create `.planning/phases/19-remove-zustand-from-pipeline-builder/19-02-SUMMARY.md`
</output>
