---
phase: 19-remove-zustand-from-pipeline-builder
plan: 04
type: execute
wave: 4
depends_on: ["19-03"]
files_modified:
  - app/components/pipeline-builder/pipeline-tab-panel.test.tsx
  - app/routes/pipelines.$id.test.tsx
  - app/components/pipeline-builder/pipeline-creation-flow.test.tsx
autonomous: true

must_haves:
  truths:
    - "Tests mock React Query cache instead of Zustand store"
    - "All pipeline-related tests pass"
    - "Test mocking approach is consistent across test files"
  artifacts:
    - path: "app/components/pipeline-builder/pipeline-tab-panel.test.tsx"
      provides: "Tests for tab panel using React Query mocks"
      contains: "queryClient"
    - path: "app/routes/pipelines.$id.test.tsx"
      provides: "Tests for route using React Query mocks"
      contains: "queryClient"
    - path: "app/components/pipeline-builder/pipeline-creation-flow.test.tsx"
      provides: "Tests for creation flow using React Query mocks"
      contains: "usePipelineFlow"
  key_links:
    - from: "app/components/pipeline-builder/pipeline-tab-panel.test.tsx"
      to: "app/hooks/queries/use-pipeline-flow.ts"
      via: "mocks usePipelineFlow"
      pattern: "vi.mock.*use-pipeline-flow"
---

<objective>
Update all test files to mock React Query instead of Zustand for pipeline state management.

Purpose: Tests currently mock usePipelineStore which no longer exists. They need to mock usePipelineFlow and React Query's cache instead. This ensures test coverage remains valid.

Output: All pipeline-related tests pass with updated mocking strategy.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-remove-zustand-from-pipeline-builder/19-03-SUMMARY.md
@app/components/pipeline-builder/pipeline-tab-panel.test.tsx
@app/routes/pipelines.$id.test.tsx
@app/components/pipeline-builder/pipeline-creation-flow.test.tsx
@app/hooks/queries/use-pipeline-flow.ts
@.claude/skills/vitest-testing/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update pipeline-tab-panel.test.tsx</name>
  <files>app/components/pipeline-builder/pipeline-tab-panel.test.tsx</files>
  <action>
Rewrite the test file to mock usePipelineFlow instead of usePipelineStore:

1. Remove old mocks:
```typescript
// REMOVE all mockPipelineData, mockGetPipeline, mockLoadPipeline, mockUpdatePipeline, etc.
// REMOVE vi.mock("~/stores/pipeline-store", ...)
```

2. Add new mock setup for usePipelineFlow:
```typescript
// Mock usePipelineFlow hook return value
let mockNodes: Node[] = [];
let mockEdges: Edge[] = [];
let mockPipelineName = "Untitled Pipeline";
let mockPipelineDescription = "";
let mockIsLoading = false;

const mockUpdateName = vi.fn((name: string) => {
  mockPipelineName = name;
});
const mockOnNodesChange = vi.fn();
const mockOnEdgesChange = vi.fn();
const mockOnConnect = vi.fn();
const mockAddAgentNode = vi.fn();
const mockAddTraitNode = vi.fn();
const mockSetNodesAndEdges = vi.fn();

vi.mock("~/hooks/queries/use-pipeline-flow", () => ({
  usePipelineFlow: vi.fn(() => ({
    nodes: mockNodes,
    edges: mockEdges,
    pipelineName: mockPipelineName,
    pipelineDescription: mockPipelineDescription,
    isLoading: mockIsLoading,
    onNodesChange: mockOnNodesChange,
    onEdgesChange: mockOnEdgesChange,
    onConnect: mockOnConnect,
    updateName: mockUpdateName,
    updateDescription: vi.fn(),
    addAgentNode: mockAddAgentNode,
    addTraitNode: mockAddTraitNode,
    removeNode: vi.fn(),
    addTraitToNode: vi.fn(),
    removeTraitFromNode: vi.fn(),
    setNodesAndEdges: mockSetNodesAndEdges,
  })),
}));
```

3. Keep tab store mock (still used):
```typescript
vi.mock("~/stores/tab-store", () => ({
  useTabStore: vi.fn(() => ({
    updateTabName: mockUpdateTabName,
  })),
}));
```

4. Update test cases:

For "displays pipeline name from initialData when available on mount":
```typescript
test("displays pipeline name from initialData when available on mount", async () => {
  // Set mock state before render
  mockPipelineName = "My Custom Pipeline";

  renderWithClient(
    <PipelineTabPanel
      {...defaultProps}
      initialData={{
        id: "test-pipeline-1",
        name: "My Custom Pipeline",
        description: "Test description",
        flowData: { nodes: [], edges: [] },
      }}
    />
  );

  await waitFor(() => {
    expect(screen.getByPlaceholderText("Pipeline name")).toBeInTheDocument();
  });

  const nameInput = screen.getByPlaceholderText("Pipeline name");
  expect(nameInput).toHaveValue("My Custom Pipeline");
});
```

For "editing name updates store and triggers save":
```typescript
test("editing name updates and triggers save", async () => {
  const user = userEvent.setup();
  mockPipelineName = "Original Name";

  renderWithClient(
    <PipelineTabPanel
      {...defaultProps}
      initialData={{
        id: "test-pipeline-1",
        name: "Original Name",
        description: null,
        flowData: { nodes: [], edges: [] },
      }}
    />
  );

  await waitFor(() => {
    expect(screen.getByPlaceholderText("Pipeline name")).toBeInTheDocument();
  });

  const nameInput = screen.getByPlaceholderText("Pipeline name");
  expect(nameInput).toHaveValue("Original Name");

  await user.clear(nameInput);
  await user.type(nameInput, "New Name");

  // Should call updateName from the hook
  expect(mockUpdateName).toHaveBeenCalled();

  // Should update tab name
  expect(mockUpdateTabName).toHaveBeenCalled();
});
```

5. Update resetAllMocks helper:
```typescript
function resetAllMocks() {
  mockNodes = [];
  mockEdges = [];
  mockPipelineName = "Untitled Pipeline";
  mockPipelineDescription = "";
  mockIsLoading = false;

  mockUpdateName.mockClear();
  mockUpdateName.mockImplementation((name: string) => {
    mockPipelineName = name;
  });
  mockOnNodesChange.mockClear();
  mockOnEdgesChange.mockClear();
  mockOnConnect.mockClear();
  mockAddAgentNode.mockClear();
  mockAddTraitNode.mockClear();
  mockSetNodesAndEdges.mockClear();
  mockUpdateTabName.mockClear();
  mockSavePipelineMutate.mockClear();
  mockDeletePipelineMutate.mockClear();
}
```

6. Remove tests that tested Zustand-specific behavior (like lazy initialization via loadPipeline) - the hook handles this differently.

7. Adjust remaining tests to work with the new mock structure.
  </action>
  <verify>Run `npm test app/components/pipeline-builder/pipeline-tab-panel.test.tsx` - all tests should pass</verify>
  <done>pipeline-tab-panel.test.tsx uses usePipelineFlow mocks, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Update pipelines.$id.test.tsx</name>
  <files>app/routes/pipelines.$id.test.tsx</files>
  <action>
Update the route test file to remove pipeline-store mocking:

1. Remove pipeline store mock:
```typescript
// REMOVE:
vi.mock("~/stores/pipeline-store", () => ({ ... }));
// REMOVE: mockRemovePipeline, mockGetPipeline, mockLoadPipeline, mockUpdatePipeline, etc.
```

2. The route now uses queryClient directly, so tests need to mock the query cache behavior. Two approaches:

Option A: Mock usePipelineFlow (simpler, consistent with tab-panel tests):
```typescript
vi.mock("~/hooks/queries/use-pipeline-flow", () => ({
  usePipelineFlow: vi.fn(() => ({
    nodes: [],
    edges: [],
    pipelineName: "Test Pipeline",
    pipelineDescription: "",
    isLoading: false,
    onNodesChange: vi.fn(),
    onEdgesChange: vi.fn(),
    onConnect: vi.fn(),
    updateName: vi.fn(),
    updateDescription: vi.fn(),
    addAgentNode: vi.fn(),
    addTraitNode: vi.fn(),
    removeNode: vi.fn(),
    addTraitToNode: vi.fn(),
    removeTraitFromNode: vi.fn(),
    setNodesAndEdges: vi.fn(),
  })),
}));
```

Option B: Use real queryClient with seeded data (more integration-style):
The renderWithClient utility already provides a queryClient. We can seed it with data:
```typescript
const { queryClient } = renderWithClient(<PipelineEditorPage />);
queryClient.setQueryData(["pipelines", "p1"], {
  id: "p1",
  name: "Test Pipeline",
  description: null,
  flowData: { nodes: [], edges: [] },
});
```

Best approach: Use Option A for unit test isolation, but keep tests focused on behavior.

3. Update test setup:
```typescript
// Add to mocks
const mockUsePipelineFlow = vi.fn();

vi.mock("~/hooks/queries/use-pipeline-flow", () => ({
  usePipelineFlow: (pipelineId: string) => mockUsePipelineFlow(pipelineId),
}));

// In beforeEach:
mockUsePipelineFlow.mockReturnValue({
  nodes: [],
  edges: [],
  pipelineName: "Test Pipeline",
  pipelineDescription: "",
  isLoading: false,
  onNodesChange: vi.fn(),
  onEdgesChange: vi.fn(),
  onConnect: vi.fn(),
  updateName: vi.fn(),
  updateDescription: vi.fn(),
  addAgentNode: vi.fn(),
  addTraitNode: vi.fn(),
  removeNode: vi.fn(),
  addTraitToNode: vi.fn(),
  removeTraitFromNode: vi.fn(),
  setNodesAndEdges: vi.fn(),
});
```

4. Update tests that checked mockGetPipeline:
- For "shows loading state" test: check mockUsePipelineFlow was called
- For tab close tests: verify queryClient.removeQueries was called (may need to spy)
- For run completion tests: seed queryClient with pipeline data

5. For tests that verify cache interactions, use queryClient from renderWithClient:
```typescript
test("closing tab removes pipeline from cache", async () => {
  const user = userEvent.setup();

  // Setup...
  const { queryClient } = renderWithClient(<PipelineEditorPage />);

  // Seed cache
  queryClient.setQueryData(["pipelines", "p1"], {
    id: "p1",
    name: "Test Pipeline",
    description: null,
    flowData: { nodes: [], edges: [] },
  });

  // ... close tab ...

  // Verify cache cleared
  expect(queryClient.getQueryData(["pipelines", "p1"])).toBeUndefined();
});
```

6. Remove references to mockPipelineData Map and related Zustand mock functions.

7. Keep tab-store mock as-is (still in use).
  </action>
  <verify>Run `npm test app/routes/pipelines.$id.test.tsx` - all tests should pass</verify>
  <done>pipelines.$id.test.tsx uses React Query mocks, no pipeline-store references, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Update pipeline-creation-flow.test.tsx</name>
  <files>app/components/pipeline-builder/pipeline-creation-flow.test.tsx</files>
  <action>
Update pipeline-creation-flow.test.tsx to remove pipeline-store mocking:

**All 3 test files needing updates:**
1. app/components/pipeline-builder/pipeline-tab-panel.test.tsx (Task 1)
2. app/routes/pipelines.$id.test.tsx (Task 2)
3. app/components/pipeline-builder/pipeline-creation-flow.test.tsx (this task)

For pipeline-creation-flow.test.tsx:

1. Read the file and identify all pipeline-store mocks.

2. Remove pipeline-store mock:
```typescript
// REMOVE:
vi.mock("~/stores/pipeline-store", () => ({ ... }));
```

3. Add usePipelineFlow mock if the component uses it:
```typescript
vi.mock("~/hooks/queries/use-pipeline-flow", () => ({
  usePipelineFlow: vi.fn(() => ({
    nodes: [],
    edges: [],
    pipelineName: "Untitled Pipeline",
    pipelineDescription: "",
    isLoading: false,
    onNodesChange: vi.fn(),
    onEdgesChange: vi.fn(),
    onConnect: vi.fn(),
    updateName: vi.fn(),
    updateDescription: vi.fn(),
    addAgentNode: vi.fn(),
    addTraitNode: vi.fn(),
    removeNode: vi.fn(),
    addTraitToNode: vi.fn(),
    removeTraitFromNode: vi.fn(),
    setNodesAndEdges: vi.fn(),
  })),
}));
```

4. Update any assertions that relied on pipeline-store behavior.

5. Run full test suite after all 3 files are updated:
```bash
npm test
```

6. Fix any remaining test failures related to the migration.

7. Verify no test file imports from pipeline-store:
```bash
grep -r "pipeline-store" app/**/*.test.tsx
```

Should return no results.
  </action>
  <verify>Run `npm test` - ALL tests should pass. Run `npm run typecheck` - should pass.</verify>
  <done>All 3 test files updated, all tests pass, no test files reference pipeline-store</done>
</task>

</tasks>

<verification>
1. `npm test` passes with all tests green
2. `npm run typecheck` passes with zero errors
3. `grep -r "pipeline-store" app/` returns no results (source or test files)
4. All pipeline functionality works correctly (manual verification from Plan 03)
</verification>

<success_criteria>
1. All 3 test files mock usePipelineFlow instead of usePipelineStore
2. `npm test` passes with zero failures
3. `npm run typecheck` passes with zero errors
4. No references to pipeline-store remain in codebase
5. Test coverage is maintained (same behaviors tested, different mock approach)
</success_criteria>

<output>
After completion, create `.planning/phases/19-remove-zustand-from-pipeline-builder/19-04-SUMMARY.md`
</output>
