---
phase: 19-remove-zustand-from-pipeline-builder
plan: 03
type: execute
wave: 3
depends_on: ["19-02"]
files_modified:
  - app/components/pipeline-builder/agent-node.tsx
  - app/routes/pipelines.$id.tsx
  - app/stores/pipeline-store.ts
autonomous: true

must_haves:
  truths:
    - "AgentNode gets pipelineId from context and uses React Query for trait operations"
    - "pipelines.$id.tsx no longer imports from pipeline-store"
    - "pipeline-store.ts is deleted"
    - "Tab close cleanup uses React Query cache instead of Zustand"
  artifacts:
    - path: "app/components/pipeline-builder/agent-node.tsx"
      provides: "Agent node using React Query for trait operations"
      contains: "usePipelineContext"
    - path: "app/routes/pipelines.$id.tsx"
      provides: "Route without Zustand dependency"
      exports: ["default"]
  key_links:
    - from: "app/components/pipeline-builder/agent-node.tsx"
      to: "app/components/pipeline-builder/pipeline-context.tsx"
      via: "usePipelineContext"
      pattern: "usePipelineContext"
    - from: "app/routes/pipelines.$id.tsx"
      to: "app/hooks/queries/use-pipelines.ts"
      via: "usePipeline for reading cache"
      pattern: "usePipeline"
---

<objective>
Complete the migration by updating remaining consumers (AgentNode, route) and deleting the Zustand pipeline-store.

Purpose: This plan finalizes the migration. AgentNode needs trait operations routed through React Query. The route file needs cleanup. Finally, pipeline-store.ts is deleted to ensure no regression back to the old pattern.

Output: All pipeline state management flows through React Query. The Zustand pipeline-store is gone.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-remove-zustand-from-pipeline-builder/19-RESEARCH.md
@.planning/phases/19-remove-zustand-from-pipeline-builder/19-02-SUMMARY.md
@app/components/pipeline-builder/agent-node.tsx
@app/routes/pipelines.$id.tsx
@app/stores/pipeline-store.ts
@app/hooks/queries/use-pipeline-flow.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AgentNode to use React Query via context</name>
  <files>app/components/pipeline-builder/agent-node.tsx</files>
  <action>
Update AgentNode to get pipelineId from context and use React Query for trait operations:

1. Remove imports:
```typescript
// REMOVE:
import { usePipelineStore } from "~/stores/pipeline-store";
import type { AgentNodeData } from "~/stores/pipeline-store";
```

2. Add imports:
```typescript
import { usePipelineContext } from "./pipeline-context";
import { useQueryClient } from "@tanstack/react-query";
import type { AgentNodeData, Pipeline, FlowData } from "~/hooks/queries/use-pipelines";
```

3. Get pipelineId from context:
```typescript
const { pipelineId } = usePipelineContext();
const queryClient = useQueryClient();
```

4. Implement addTraitToNode using setQueryData:
```typescript
const addTraitToNode = useCallback((nodeId: string, traitId: string) => {
  queryClient.setQueryData<Pipeline>(
    ["pipelines", pipelineId],
    (old) => {
      if (!old) return old;
      const flowData = old.flowData as FlowData;
      return {
        ...old,
        flowData: {
          ...flowData,
          nodes: flowData.nodes.map((node) => {
            if (node.id !== nodeId || node.type !== "agent") return node;
            const agentData = node.data as AgentNodeData;
            return {
              ...node,
              data: {
                ...agentData,
                traitIds: [...new Set([...(agentData.traitIds || []), traitId])],
              },
            };
          }),
        },
      };
    }
  );
}, [queryClient, pipelineId]);
```

5. Implement removeTraitFromNode similarly:
```typescript
const removeTraitFromNode = useCallback((nodeId: string, traitId: string) => {
  queryClient.setQueryData<Pipeline>(
    ["pipelines", pipelineId],
    (old) => {
      if (!old) return old;
      const flowData = old.flowData as FlowData;
      return {
        ...old,
        flowData: {
          ...flowData,
          nodes: flowData.nodes.map((node) => {
            if (node.id !== nodeId || node.type !== "agent") return node;
            const agentData = node.data as AgentNodeData;
            return {
              ...node,
              data: {
                ...agentData,
                traitIds: (agentData.traitIds || []).filter((id) => id !== traitId),
              },
            };
          }),
        },
      };
    }
  );
}, [queryClient, pipelineId]);
```

Note: These changes update the cache immediately. The debounced save in usePipelineFlow will persist them.

WAIT - the debounced save is in usePipelineFlow, but AgentNode doesn't use that hook. We need to trigger a save somehow.

Options:
a) Pass a triggerSave callback from parent
b) Have AgentNode also call usePipelineFlow
c) Accept that trait changes won't auto-save until next canvas change

Best approach: Pass an optional `onTraitChange` callback from parent that calls the debounced save.

Actually, simpler: Since usePipelineFlow is used in PipelineTabPanel and it uses setQueryData with a watcher pattern, the cache change will be detected. BUT the debounced save only triggers on explicit hook method calls, not on external setQueryData.

Simplest fix: Have AgentNode call usePipelineFlow too. The hook is designed to be called multiple times with same pipelineId - they share the same cache.

Update approach:
```typescript
import { usePipelineFlow } from "~/hooks/queries/use-pipeline-flow";

// In component:
const { pipelineId } = usePipelineContext();
const { addTraitToNode, removeTraitFromNode } = usePipelineFlow(pipelineId);

// Use directly in handlers
const handleDrop = (e: React.DragEvent) => {
  e.preventDefault();
  setIsDragOver(false);
  const traitId = e.dataTransfer.getData("application/trait-id");
  if (traitId) {
    addTraitToNode(id, traitId);
  }
};

const handleRemoveTrait = (traitId: string) => {
  removeTraitFromNode(id, traitId);
};
```

This is cleaner - AgentNode uses the same hook, which has the debounced save built in.
  </action>
  <verify>Run `npm run typecheck` - should pass. Manual test: drag trait onto agent node, verify it appears and persists.</verify>
  <done>AgentNode uses usePipelineFlow via context, no Zustand import</done>
</task>

<task type="auto">
  <name>Task 2: Update pipelines.$id.tsx route to remove Zustand dependency</name>
  <files>app/routes/pipelines.$id.tsx</files>
  <action>
Update the route file to remove pipeline-store dependency:

1. Remove imports:
```typescript
// REMOVE:
import { usePipelineStore } from "~/stores/pipeline-store";
import type { AgentNodeData } from "~/stores/pipeline-store";
```

2. Add imports:
```typescript
import type { AgentNodeData, FlowData } from "~/hooks/queries/use-pipelines";
import { useQueryClient } from "@tanstack/react-query";
```

3. Remove Zustand store usage:
```typescript
// REMOVE:
const { removePipeline, getPipeline } = usePipelineStore();
```

4. Add query client:
```typescript
const queryClient = useQueryClient();
```

5. Update handleTabClose to use React Query cache removal:
```typescript
const handleTabClose = useCallback(
  (pipelineId: string) => {
    closeTab(pipelineId);
    // Remove from React Query cache instead of Zustand
    queryClient.removeQueries({ queryKey: ["pipelines", pipelineId] });
    setRunStates((prev) => {
      const next = new Map(prev);
      next.delete(pipelineId);
      return next;
    });
    setCompletedOutputs((prev) => {
      const next = new Map(prev);
      next.delete(pipelineId);
      return next;
    });

    // Navigate to first remaining tab or home
    const remaining = tabs.filter(
      (t) => t.pipelineId !== pipelineId && t.pipelineId !== HOME_TAB_ID
    );
    if (remaining.length > 0) {
      navigate(`/pipelines/${remaining[0].pipelineId}`);
    } else {
      navigate("/pipelines/home");
    }
  },
  [closeTab, queryClient, tabs, navigate]
);
```

6. Update handleRunComplete to read from React Query cache:
```typescript
const handleRunComplete = useCallback(
  (
    pipelineId: string,
    finalOutput: string,
    stepOutputs: Map<number, string>,
    stepInputs: Map<number, string>,
    usage: { inputTokens: number; outputTokens: number } | null,
    model: string | null
  ) => {
    const pipeline = queryClient.getQueryData<Pipeline>(["pipelines", pipelineId]);
    if (!pipeline) return;

    const flowData = pipeline.flowData as FlowData;
    const steps = flowData.nodes
      .filter((n) => n.type === "agent")
      .map((node, index) => ({
        agentName: (node.data as AgentNodeData).agentName,
        output: stepOutputs.get(index) || "",
        input: stepInputs.get(index) || "",
      }));

    setCompletedOutputs((prev) =>
      new Map(prev).set(pipelineId, {
        steps,
        finalOutput,
        usage,
        model,
      })
    );
    setRunState(pipelineId, { runId: null, isStarting: false });
  },
  [queryClient]
);
```

7. Import Pipeline type:
```typescript
import { usePipeline, useRunPipeline, type Pipeline } from "~/hooks/queries/use-pipelines";
```

8. Update RunProgress steps extraction to use query client:
```typescript
{runState.runId && (
  <div className="fixed bottom-4 right-4 w-96 z-50">
    <RunProgress
      runId={runState.runId}
      steps={(() => {
        const pipeline = queryClient.getQueryData<Pipeline>(["pipelines", tab.pipelineId]);
        if (!pipeline) return [];
        const flowData = pipeline.flowData as FlowData;
        return flowData.nodes
          .filter((n) => n.type === "agent")
          .map((n) => ({
            agentId: (n.data as AgentNodeData).agentId,
            agentName: (n.data as AgentNodeData).agentName,
          }));
      })()}
      onComplete={(final, outputs, inputs, usage, model) =>
        handleRunComplete(tab.pipelineId, final, outputs, inputs, usage, model)
      }
      onError={(err) => handleRunError(tab.pipelineId, err)}
    />
  </div>
)}
```

Better: Extract to a helper or useMemo to avoid recreating on each render:
```typescript
// Near top of component, after queryClient is defined
const getStepsForPipeline = useCallback((pipelineId: string) => {
  const pipeline = queryClient.getQueryData<Pipeline>(["pipelines", pipelineId]);
  if (!pipeline) return [];
  const flowData = pipeline.flowData as FlowData;
  return flowData.nodes
    .filter((n) => n.type === "agent")
    .map((n) => ({
      agentId: (n.data as AgentNodeData).agentId,
      agentName: (n.data as AgentNodeData).agentName,
    }));
}, [queryClient]);

// In JSX:
steps={getStepsForPipeline(tab.pipelineId)}
```

9. Update OutputViewer pipelineName to use query client:
```typescript
pipelineName={
  queryClient.getQueryData<Pipeline>(["pipelines", pipelineId])?.name || "Pipeline"
}
```

10. Remove the line checking pipelineAlreadyInStore:
```typescript
// REMOVE:
const pipelineAlreadyInStore = !!getPipeline(tab.pipelineId);
```

Replace with cache check:
```typescript
const pipelineInCache = !!queryClient.getQueryData(["pipelines", tab.pipelineId]);
```

And update shouldWaitForData accordingly.
  </action>
  <verify>Run `npm run typecheck` - should pass. Manual test: close tab, verify no errors. Run pipeline, verify progress shows.</verify>
  <done>pipelines.$id.tsx has no imports from pipeline-store, uses React Query cache</done>
</task>

<task type="auto">
  <name>Task 3: Delete pipeline-store.ts</name>
  <files>app/stores/pipeline-store.ts</files>
  <action>
Delete the file:
```bash
rm app/stores/pipeline-store.ts
```

Then verify no remaining imports:
```bash
grep -r "pipeline-store" app/
```

If any imports remain, they are errors that must be fixed. The grep should return no results from .ts/.tsx files (may show in .test.tsx files which we'll fix in Plan 04).
  </action>
  <verify>Run `npm run typecheck && npm test` - typecheck should pass. Tests may fail (expected, will fix in Plan 04).</verify>
  <done>pipeline-store.ts is deleted, no runtime code imports it</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `grep -r "pipeline-store" app/` returns no results from source files (only test files)
3. `app/stores/pipeline-store.ts` does not exist
4. Manual testing:
   - Drag trait onto agent node - appears as chip
   - Click X on trait chip - trait is removed
   - Close pipeline tab - no errors
   - Run pipeline - progress displays correctly
   - Output viewer shows correct pipeline name
</verification>

<success_criteria>
1. AgentNode uses usePipelineFlow for trait operations
2. Route file uses queryClient instead of Zustand
3. pipeline-store.ts is deleted
4. All pipeline operations work correctly
5. TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-remove-zustand-from-pipeline-builder/19-03-SUMMARY.md`
</output>
