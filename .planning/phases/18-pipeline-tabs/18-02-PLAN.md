---
phase: 18-pipeline-tabs
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - app/components/pipeline-builder/pipeline-tabs.tsx
  - app/components/pipeline-builder/pipeline-tab-panel.tsx
  - app/components/pipeline-builder/pipeline-canvas.tsx
autonomous: true

must_haves:
  truths:
    - "Tab bar displays below app nav with browser-style tabs"
    - "Each tab shows pipeline name with close button on hover"
    - "Inactive tabs remain mounted but CSS hidden"
    - "Switching tabs preserves React Flow state (zoom, pan, selection)"
  artifacts:
    - path: "app/components/pipeline-builder/pipeline-tabs.tsx"
      provides: "Tab bar component with new tab button"
      exports: ["PipelineTabs"]
    - path: "app/components/pipeline-builder/pipeline-tab-panel.tsx"
      provides: "Single tab content wrapper with ReactFlowProvider"
      exports: ["PipelineTabPanel"]
  key_links:
    - from: "app/components/pipeline-builder/pipeline-tabs.tsx"
      to: "app/stores/tab-store.ts"
      via: "useTabStore hook"
      pattern: "useTabStore"
    - from: "app/components/pipeline-builder/pipeline-tab-panel.tsx"
      to: "app/stores/pipeline-store.ts"
      via: "usePipelineStore hook"
      pattern: "usePipelineStore"
---

<objective>
Create the tab bar UI and CSS-hidden tab panel container.

Purpose: Users see browser-style tabs for their open pipelines. Each pipeline editor maintains state when switching tabs because content stays mounted but hidden with CSS.

Output: Tab bar component + tab panel wrapper that isolates React Flow instances.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-pipeline-tabs/18-RESEARCH.md
@.planning/phases/18-pipeline-tabs/18-01-SUMMARY.md

@app/stores/tab-store.ts
@app/stores/pipeline-store.ts
@app/components/pipeline-builder/pipeline-canvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tab bar component</name>
  <files>app/components/pipeline-builder/pipeline-tabs.tsx</files>
  <action>
Create the browser-style tab bar component.

Visual design (follow design system):
- Height: h-10 (40px)
- Background: bg-muted/30 with bottom border
- Tabs: rounded-t-md corners, active tab has border-primary bottom and bg-background
- Tab content: truncated name (max-w-32), X button visible on hover (group-hover:opacity-100)
- New tab button (+) at end, disabled when at 8 tabs

Implementation:
```typescript
import { X, Plus } from 'lucide-react';
import { useNavigate } from 'react-router';
import { useTabStore } from '~/stores/tab-store';
import { cn } from '~/lib/utils';
import { Button } from '~/components/ui/button';
import { toast } from 'sonner';

export function PipelineTabs() {
  const navigate = useNavigate();
  const { tabs, activeTabId, closeTab, canOpenNewTab } = useTabStore();

  const handleTabClick = (pipelineId: string) => {
    navigate(`/pipelines/${pipelineId}`);
  };

  const handleClose = (e: React.MouseEvent, pipelineId: string) => {
    e.stopPropagation();
    // TODO: Plan 04 will add running pipeline check here
    closeTab(pipelineId);

    // Navigate to remaining tab or pipelines list
    const remaining = tabs.filter(t => t.pipelineId !== pipelineId);
    if (remaining.length > 0) {
      const lastTab = remaining[remaining.length - 1];
      navigate(`/pipelines/${lastTab.pipelineId}`);
    } else {
      navigate('/pipelines');
    }
  };

  const handleNewTab = async () => {
    if (!canOpenNewTab()) {
      toast.error('Maximum 8 tabs allowed');
      return;
    }

    // Create new pipeline in DB immediately
    const formData = new FormData();
    formData.set('intent', 'create');
    formData.set('name', 'Untitled Pipeline');
    formData.set('flowData', JSON.stringify({ nodes: [], edges: [] }));

    const response = await fetch('/api/pipelines', {
      method: 'POST',
      body: formData,
    });

    const { pipeline } = await response.json();
    navigate(`/pipelines/${pipeline.id}`);
  };

  if (tabs.length === 0) {
    return null; // No tabs = no tab bar
  }

  return (
    <div className="flex items-center border-b bg-muted/30 px-2 h-10">
      {tabs.map((tab) => (
        <button
          key={tab.pipelineId}
          onClick={() => handleTabClick(tab.pipelineId)}
          className={cn(
            "group flex items-center gap-2 px-3 py-1.5 text-sm rounded-t-md border-b-2 transition-colors",
            "hover:bg-background/50",
            activeTabId === tab.pipelineId
              ? "border-primary bg-background"
              : "border-transparent"
          )}
        >
          <span className="max-w-32 truncate">{tab.name}</span>
          <button
            onClick={(e) => handleClose(e, tab.pipelineId)}
            className="opacity-0 group-hover:opacity-100 hover:bg-muted rounded p-0.5 -mr-1"
          >
            <X className="size-3" />
          </button>
        </button>
      ))}
      <Button
        variant="ghost"
        size="icon"
        onClick={handleNewTab}
        disabled={!canOpenNewTab()}
        className="size-8 ml-1"
      >
        <Plus className="size-4" />
      </Button>
    </div>
  );
}
```
  </action>
  <verify>Component renders without errors in browser</verify>
  <done>Tab bar shows all open tabs with close buttons, + button creates new pipeline</done>
</task>

<task type="auto">
  <name>Task 2: Create tab panel wrapper component</name>
  <files>app/components/pipeline-builder/pipeline-tab-panel.tsx</files>
  <action>
Create a component that wraps individual pipeline editor content with its own ReactFlowProvider.

This component handles:
- Loading pipeline data into the multi-pipeline store
- Providing an isolated ReactFlowProvider for this tab
- Rendering pipeline header (name input, action buttons)
- Rendering PipelineCanvas

```typescript
import { useEffect, useMemo, useCallback, useState } from 'react';
import { useNavigate } from 'react-router';
import { ReactFlowProvider } from '@xyflow/react';
import { usePipelineStore } from '~/stores/pipeline-store';
import { useTabStore } from '~/stores/tab-store';
import { PipelineCanvas } from './pipeline-canvas';
import { Input } from '~/components/ui/input';
import { Button } from '~/components/ui/button';
import { LayoutGrid, Save, Trash2, Play, Loader2, AlertTriangle } from 'lucide-react';
import { getLayoutedElements } from '~/lib/pipeline-layout';
import type { Node, Edge } from '@xyflow/react';
import type { AgentNodeData, PipelineNodeData } from '~/stores/pipeline-store';

interface PipelineTabPanelProps {
  pipelineId: string;
  initialData: {
    id: string;
    name: string;
    description: string | null;
    flowData: { nodes: Node<PipelineNodeData>[]; edges: Edge[] };
  } | null; // null for new pipeline
  agents: Array<{ id: string; name: string; instructions: string | null }>;
  traits: Array<{ id: string; name: string; color: string }>;
  traitsMap: Map<string, { id: string; name: string; color: string; content: string }>;
  onRunStart: (runId: string) => void;
  runState: { runId: string | null; isStarting: boolean };
}

export function PipelineTabPanel({
  pipelineId,
  initialData,
  agents,
  traits,
  traitsMap,
  onRunStart,
  runState,
}: PipelineTabPanelProps) {
  const navigate = useNavigate();
  const [isSaving, setIsSaving] = useState(false);

  const {
    getPipeline,
    loadPipeline,
    updatePipeline,
    createOnNodesChange,
    createOnEdgesChange,
    createOnConnect,
    addAgentNode,
    addTraitNode,
  } = usePipelineStore();

  const { updateTabName } = useTabStore();

  const pipeline = getPipeline(pipelineId);

  // Load initial data into store on mount
  useEffect(() => {
    if (!pipeline) {
      const validAgentIds = new Set(agents.map(a => a.id));
      const flowData = initialData?.flowData || { nodes: [], edges: [] };

      // Enrich nodes with orphan status
      const enrichedNodes = flowData.nodes.map(node => {
        if (node.type === 'agent') {
          const agentData = node.data as AgentNodeData;
          return {
            ...node,
            data: { ...agentData, isOrphaned: !validAgentIds.has(agentData.agentId) }
          };
        }
        return node;
      });

      loadPipeline({
        pipelineId,
        pipelineName: initialData?.name || 'Untitled Pipeline',
        pipelineDescription: initialData?.description || '',
        nodes: enrichedNodes,
        edges: flowData.edges,
        isDirty: false,
      });
    }
  }, [pipelineId, initialData, agents, pipeline, loadPipeline]);

  // Detect orphaned agents
  const hasOrphanedAgents = useMemo(() => {
    if (!pipeline) return false;
    const validAgentIds = new Set(agents.map(a => a.id));
    return pipeline.nodes.some(n => {
      if (n.type !== 'agent') return false;
      const agentData = n.data as AgentNodeData;
      return agentData.agentId && !validAgentIds.has(agentData.agentId);
    });
  }, [pipeline, agents]);

  const handleNameChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    updatePipeline(pipelineId, { pipelineName: e.target.value });
    updateTabName(pipelineId, e.target.value);
  }, [pipelineId, updatePipeline, updateTabName]);

  const handleDropAgent = useCallback((
    agentId: string,
    agentName: string,
    instructions: string | undefined,
    position: { x: number; y: number }
  ) => {
    addAgentNode(pipelineId, { id: agentId, name: agentName, instructions }, position);
  }, [pipelineId, addAgentNode]);

  const handleDropTrait = useCallback((
    traitId: string,
    traitName: string,
    traitColor: string,
    position: { x: number; y: number }
  ) => {
    addTraitNode(pipelineId, { id: traitId, name: traitName, color: traitColor }, position);
  }, [pipelineId, addTraitNode]);

  const handleAutoLayout = useCallback(() => {
    if (!pipeline) return;
    const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(
      pipeline.nodes,
      pipeline.edges
    );
    updatePipeline(pipelineId, { nodes: layoutedNodes, edges: layoutedEdges });
  }, [pipelineId, pipeline, updatePipeline]);

  const handleSave = async () => {
    if (!pipeline) return;
    setIsSaving(true);
    try {
      const formData = new FormData();
      formData.set('intent', initialData ? 'update' : 'create');
      if (initialData) {
        formData.set('id', pipelineId);
      }
      formData.set('name', pipeline.pipelineName);
      formData.set('description', pipeline.pipelineDescription);
      formData.set('flowData', JSON.stringify({ nodes: pipeline.nodes, edges: pipeline.edges }));

      const response = await fetch('/api/pipelines', {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      if (data.error) throw new Error(data.error);

      // Mark clean after save
      updatePipeline(pipelineId, { isDirty: false });
    } catch (error) {
      console.error('Failed to save pipeline:', error);
    } finally {
      setIsSaving(false);
    }
  };

  const handleDelete = async () => {
    if (!confirm('Delete this pipeline?')) return;

    const formData = new FormData();
    formData.set('intent', 'delete');
    formData.set('id', pipelineId);

    await fetch('/api/pipelines', { method: 'POST', body: formData });
    navigate('/pipelines');
  };

  const handleRun = () => {
    // This will be wired to run dialog in plan 03
  };

  if (!pipeline) {
    return <div className="flex-1 flex items-center justify-center">Loading...</div>;
  }

  const isLocked = runState.isStarting || !!runState.runId;

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div className="h-[78px] z-10 border-b bg-background p-4 flex items-center gap-4">
        <Input
          value={pipeline.pipelineName}
          onChange={handleNameChange}
          placeholder="Pipeline name"
          className="max-w-xs font-semibold"
        />
        <div className="flex-1" />
        <Button variant="outline" onClick={handleAutoLayout}>
          <LayoutGrid className="size-4 mr-2" />
          Auto Layout
        </Button>
        <Button onClick={handleSave} disabled={isSaving}>
          <Save className="size-4 mr-2" />
          {isSaving ? 'Saving...' : 'Save'}
        </Button>
        {initialData && (
          <>
            <Button
              onClick={handleRun}
              disabled={isLocked || hasOrphanedAgents}
              variant={hasOrphanedAgents ? 'outline' : 'default'}
            >
              {runState.isStarting ? (
                <><Loader2 className="size-4 mr-2 animate-spin" />Starting...</>
              ) : runState.runId ? (
                <><Loader2 className="size-4 mr-2 animate-spin" />Running...</>
              ) : hasOrphanedAgents ? (
                <><AlertTriangle className="size-4 mr-2" />Remove Deleted Agents</>
              ) : (
                <><Play className="size-4 mr-2" />Run</>
              )}
            </Button>
            <Button variant="destructive" onClick={handleDelete}>
              <Trash2 className="size-4 mr-2" />
              Delete
            </Button>
          </>
        )}
      </div>

      {/* Canvas with isolated ReactFlowProvider */}
      <div className="flex-1 min-h-0">
        <ReactFlowProvider>
          <PipelineCanvas
            pipelineId={pipelineId}
            onDropAgent={handleDropAgent}
            onDropTrait={handleDropTrait}
            isLocked={isLocked}
          />
        </ReactFlowProvider>
      </div>
    </div>
  );
}
```

Note: PipelineCanvas will need updates in Task 3 to accept pipelineId.
  </action>
  <verify>Component renders pipeline content correctly</verify>
  <done>Tab panel wraps pipeline editor with isolated ReactFlowProvider, loads data into multi-pipeline store</done>
</task>

<task type="auto">
  <name>Task 3: Update PipelineCanvas to use multi-pipeline store</name>
  <files>app/components/pipeline-builder/pipeline-canvas.tsx</files>
  <action>
Update PipelineCanvas to work with the refactored multi-pipeline store.

Changes:
1. Add `pipelineId` prop
2. Get nodes/edges from store using `getPipeline(pipelineId)`
3. Use `createOnNodesChange(pipelineId)`, `createOnEdgesChange(pipelineId)`, `createOnConnect(pipelineId)` for callbacks
4. Remove the ReactFlowProvider wrapper (now in PipelineTabPanel)

```typescript
interface PipelineCanvasProps {
  pipelineId: string;
  onDropAgent: (
    agentId: string,
    agentName: string,
    instructions: string | undefined,
    position: { x: number; y: number }
  ) => void;
  onDropTrait: (
    traitId: string,
    traitName: string,
    traitColor: string,
    position: { x: number; y: number }
  ) => void;
  isLocked?: boolean;
}

export function PipelineCanvas({ pipelineId, onDropAgent, onDropTrait, isLocked }: PipelineCanvasProps) {
  const {
    getPipeline,
    createOnNodesChange,
    createOnEdgesChange,
    createOnConnect,
  } = usePipelineStore();

  const pipeline = getPipeline(pipelineId);
  const { screenToFlowPosition } = useReactFlow();

  const onNodesChange = useMemo(() => createOnNodesChange(pipelineId), [pipelineId, createOnNodesChange]);
  const onEdgesChange = useMemo(() => createOnEdgesChange(pipelineId), [pipelineId, createOnEdgesChange]);
  const onConnect = useMemo(() => createOnConnect(pipelineId), [pipelineId, createOnConnect]);

  // ... rest of component (onDragOver, onDrop unchanged except using props)

  if (!pipeline) {
    return <div className="h-full w-full flex items-center justify-center">Loading...</div>;
  }

  return (
    <div className="h-full w-full">
      <ReactFlow
        nodes={pipeline.nodes}
        edges={pipeline.edges}
        nodeTypes={nodeTypes}
        onNodesChange={isLocked ? undefined : onNodesChange}
        onEdgesChange={isLocked ? undefined : onEdgesChange}
        onConnect={isLocked ? undefined : onConnect}
        onDragOver={onDragOver}
        onDrop={onDrop}
        fitView
        className="bg-muted/30"
        nodesDraggable={!isLocked}
        nodesConnectable={!isLocked}
        elementsSelectable={!isLocked}
        deleteKeyCode={isLocked ? null : "Backspace"}
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
    </div>
  );
}
```

Remove the `PipelineCanvasInner` wrapper pattern - the component now expects to be inside a ReactFlowProvider (provided by PipelineTabPanel).
  </action>
  <verify>Canvas renders nodes/edges from multi-pipeline store correctly</verify>
  <done>PipelineCanvas uses pipelineId to access correct pipeline state from multi-pipeline store</done>
</task>

</tasks>

<verification>
1. Tab bar renders with correct styling
2. Clicking tab navigates to /pipelines/{id}
3. Close button removes tab and navigates appropriately
4. + button creates new pipeline and opens it
5. Each tab panel has isolated React Flow (test: zoom one, other unaffected)
6. Pipeline state persists when switching tabs
</verification>

<success_criteria>
- Tab bar component with browser-style styling
- Tab panels keep React Flow mounted but CSS-hidden when inactive
- Each tab has isolated ReactFlowProvider
- PipelineCanvas works with multi-pipeline store
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/18-pipeline-tabs/18-02-SUMMARY.md`
</output>
