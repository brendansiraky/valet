---
phase: 18-pipeline-tabs
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - app/hooks/use-autosave.ts
  - app/routes/pipelines.$id.tsx
autonomous: true

must_haves:
  truths:
    - "Canvas changes trigger immediate autosave (debounced)"
    - "URL navigation syncs with tab store"
    - "Browser refresh restores tabs from localStorage"
    - "Direct URL access opens pipeline in new tab if not already open"
  artifacts:
    - path: "app/hooks/use-autosave.ts"
      provides: "Debounced autosave hook for dirty pipelines"
      exports: ["useAutosave"]
    - path: "app/routes/pipelines.$id.tsx"
      provides: "Refactored route with tab container and URL sync"
      exports: ["default", "loader"]
  key_links:
    - from: "app/hooks/use-autosave.ts"
      to: "/api/pipelines"
      via: "fetch POST on dirty flag"
      pattern: "fetch.*api/pipelines"
    - from: "app/routes/pipelines.$id.tsx"
      to: "app/stores/tab-store.ts"
      via: "URL param sync with tab store"
      pattern: "useTabStore"
---

<objective>
Implement autosave and refactor the route to be a tab container.

Purpose: Changes save automatically without user clicking Save. Route becomes a container that renders all open tabs with CSS hiding, syncing URL to active tab.

Output: Autosave hook and refactored route that manages multiple tab panels.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-pipeline-tabs/18-RESEARCH.md
@.planning/phases/18-pipeline-tabs/18-01-SUMMARY.md

@app/stores/tab-store.ts
@app/stores/pipeline-store.ts
@app/routes/pipelines.$id.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create autosave hook</name>
  <files>app/hooks/use-autosave.ts</files>
  <action>
Create a hook that watches a pipeline's isDirty flag and saves when dirty.

Implementation without external dependencies (manual debounce):
```typescript
import { useEffect, useRef, useCallback } from 'react';
import { usePipelineStore } from '~/stores/pipeline-store';

const AUTOSAVE_DELAY = 1000; // 1 second debounce

export function useAutosave(pipelineId: string) {
  const { getPipeline, updatePipeline } = usePipelineStore();
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const isSavingRef = useRef(false);

  const save = useCallback(async () => {
    const pipeline = getPipeline(pipelineId);
    if (!pipeline || !pipeline.isDirty || isSavingRef.current) return;

    // Abort any in-flight request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();
    isSavingRef.current = true;

    try {
      const formData = new FormData();
      formData.set('intent', 'update');
      formData.set('id', pipelineId);
      formData.set('name', pipeline.pipelineName);
      formData.set('description', pipeline.pipelineDescription);
      formData.set('flowData', JSON.stringify({
        nodes: pipeline.nodes,
        edges: pipeline.edges,
      }));

      const response = await fetch('/api/pipelines', {
        method: 'POST',
        body: formData,
        signal: abortControllerRef.current.signal,
      });

      if (response.ok) {
        // Only mark clean if still the same data (no new changes during save)
        const currentPipeline = getPipeline(pipelineId);
        if (currentPipeline?.isDirty) {
          updatePipeline(pipelineId, { isDirty: false });
        }
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        // Request was cancelled, new one will be made
        return;
      }
      console.error('Autosave failed:', error);
    } finally {
      isSavingRef.current = false;
    }
  }, [pipelineId, getPipeline, updatePipeline]);

  // Watch for dirty flag and debounce save
  useEffect(() => {
    const pipeline = getPipeline(pipelineId);
    if (!pipeline?.isDirty) return;

    // Clear existing timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // Set new timeout
    timeoutRef.current = setTimeout(save, AUTOSAVE_DELAY);

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [pipelineId, getPipeline, save]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Return manual save for Save button (bypasses debounce)
  const saveNow = useCallback(async () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    await save();
  }, [save]);

  return { saveNow };
}
```

Key behaviors:
- Watches isDirty flag in the store
- Debounces saves by 1 second
- Aborts in-flight requests when new changes come in
- Only marks clean after successful save
- Exposes `saveNow` for manual Save button
  </action>
  <verify>Autosave triggers after editing, visible in Network tab</verify>
  <done>Autosave hook debounces saves by 1 second, handles race conditions</done>
</task>

<task type="auto">
  <name>Task 2: Refactor route to tab container</name>
  <files>app/routes/pipelines.$id.tsx</files>
  <action>
Transform the route from a single pipeline editor to a tab container that:
1. Shows tab bar (from Plan 02)
2. Renders ALL open tabs with CSS display:none for inactive
3. Syncs URL param to tab store
4. Handles opening pipeline from URL (direct access / refresh)

```typescript
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useLoaderData, useNavigate, useParams } from 'react-router';
import type { LoaderFunctionArgs } from 'react-router';
import { redirect } from 'react-router';
import { getSession } from '~/services/session.server';
import { db, pipelines, agents, traits } from '~/db';
import { eq, and, inArray } from 'drizzle-orm';
import { useTabStore } from '~/stores/tab-store';
import { usePipelineStore } from '~/stores/pipeline-store';
import { PipelineTabs } from '~/components/pipeline-builder/pipeline-tabs';
import { PipelineTabPanel } from '~/components/pipeline-builder/pipeline-tab-panel';
import { AgentSidebar } from '~/components/pipeline-builder/agent-sidebar';
import { TraitsContext } from '~/components/pipeline-builder/traits-context';
import { RunProgress } from '~/components/pipeline-runner/run-progress';
import { OutputViewer } from '~/components/output-viewer/output-viewer';
import {
  Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter,
} from '~/components/ui/dialog';
import { Textarea } from '~/components/ui/textarea';
import { Button } from '~/components/ui/button';
import { Play } from 'lucide-react';
import type { Node, Edge } from '@xyflow/react';
import type { PipelineNodeData } from '~/stores/pipeline-store';
import { useAutosave } from '~/hooks/use-autosave';

// Loader returns data for the requested pipeline AND all open tab pipelines
export async function loader({ request, params }: LoaderFunctionArgs) {
  const session = await getSession(request.headers.get('Cookie'));
  const userId = session.get('userId');

  if (!userId) {
    return redirect('/login');
  }

  const { id } = params;

  // Fetch user's agents and traits for sidebar
  const [userAgents, userTraits] = await Promise.all([
    db.select().from(agents).where(eq(agents.userId, userId)),
    db.select().from(traits).where(eq(traits.userId, userId)).orderBy(traits.name),
  ]);

  // For new pipelines, return null pipeline
  if (id === 'new') {
    return {
      requestedPipeline: null,
      requestedId: 'new',
      agents: userAgents,
      traits: userTraits,
    };
  }

  // Load the requested pipeline
  const [requestedPipeline] = await db
    .select()
    .from(pipelines)
    .where(and(eq(pipelines.id, id!), eq(pipelines.userId, userId)));

  if (!requestedPipeline) {
    throw new Response('Pipeline not found', { status: 404 });
  }

  return {
    requestedPipeline,
    requestedId: id,
    agents: userAgents,
    traits: userTraits,
  };
}

export default function PipelineEditorPage() {
  const { requestedPipeline, requestedId, agents: userAgents, traits: userTraits } = useLoaderData<typeof loader>();
  const { id: urlId } = useParams();
  const navigate = useNavigate();

  const { tabs, activeTabId, setActiveTab, focusOrOpenTab } = useTabStore();
  const { removePipeline, getPipeline } = usePipelineStore();

  // Per-tab run state (lifted to container to persist across tab switches)
  const [runStates, setRunStates] = useState<Map<string, { runId: string | null; isStarting: boolean }>>(new Map());
  const [completedOutputs, setCompletedOutputs] = useState<Map<string, {
    steps: Array<{ agentName: string; output: string; input: string }>;
    finalOutput: string;
    usage: { inputTokens: number; outputTokens: number } | null;
    model: string | null;
  }>>(new Map());
  const [runDialogPipelineId, setRunDialogPipelineId] = useState<string | null>(null);
  const [runInput, setRunInput] = useState('');

  // Traits lookup map for context
  const traitsMap = useMemo(
    () => new Map(userTraits.map((t) => [t.id, t])),
    [userTraits]
  );

  // Sync URL to tab store on load/navigation
  useEffect(() => {
    if (!urlId || urlId === 'new') return;

    // Open or focus the tab for this URL
    focusOrOpenTab(urlId, requestedPipeline?.name || 'Untitled Pipeline');
  }, [urlId, requestedPipeline, focusOrOpenTab]);

  // Handle tab close cleanup
  const handleTabClose = useCallback((pipelineId: string) => {
    removePipeline(pipelineId);
    setRunStates(prev => {
      const next = new Map(prev);
      next.delete(pipelineId);
      return next;
    });
    setCompletedOutputs(prev => {
      const next = new Map(prev);
      next.delete(pipelineId);
      return next;
    });
  }, [removePipeline]);

  // Get or create run state for a pipeline
  const getRunState = (pipelineId: string) => runStates.get(pipelineId) || { runId: null, isStarting: false };

  const setRunState = (pipelineId: string, state: { runId: string | null; isStarting: boolean }) => {
    setRunStates(prev => new Map(prev).set(pipelineId, state));
  };

  // Run dialog handlers
  const handleOpenRunDialog = (pipelineId: string) => {
    setRunDialogPipelineId(pipelineId);
  };

  const handleRunSubmit = async () => {
    if (!runDialogPipelineId) return;

    setRunDialogPipelineId(null);
    setRunState(runDialogPipelineId, { runId: null, isStarting: true });

    try {
      const formData = new FormData();
      formData.set('input', runInput);

      const response = await fetch(`/api/pipeline/${runDialogPipelineId}/run`, {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      if (data.error) throw new Error(data.error);

      setRunState(runDialogPipelineId, { runId: data.runId, isStarting: false });
    } catch (error) {
      console.error('Failed to start pipeline:', error);
      setRunState(runDialogPipelineId, { runId: null, isStarting: false });
    }

    setRunInput('');
  };

  const handleRunComplete = useCallback((
    pipelineId: string,
    finalOutput: string,
    stepOutputs: Map<number, string>,
    stepInputs: Map<number, string>,
    usage: { inputTokens: number; outputTokens: number } | null,
    model: string | null
  ) => {
    const pipeline = getPipeline(pipelineId);
    if (!pipeline) return;

    const steps = pipeline.nodes
      .filter(n => n.type === 'agent')
      .map((node, index) => ({
        agentName: (node.data as any).agentName,
        output: stepOutputs.get(index) || '',
        input: stepInputs.get(index) || '',
      }));

    setCompletedOutputs(prev => new Map(prev).set(pipelineId, {
      steps, finalOutput, usage, model
    }));
    setRunState(pipelineId, { runId: null, isStarting: false });
  }, [getPipeline]);

  const handleRunError = useCallback((pipelineId: string, error: string) => {
    console.error('Pipeline failed:', error);
    setTimeout(() => setRunState(pipelineId, { runId: null, isStarting: false }), 3000);
  }, []);

  return (
    <div className="flex h-full flex-col overflow-hidden">
      {/* Tab bar */}
      <PipelineTabs />

      {/* Main content: sidebar + tab panels */}
      <div className="flex flex-1 min-h-0">
        {/* Shared sidebar */}
        <AgentSidebar agents={userAgents} traits={userTraits} />

        {/* Tab panels (CSS hidden when not active) */}
        <TraitsContext.Provider value={traitsMap}>
          <div className="flex-1 relative">
            {tabs.map(tab => {
              const isActive = tab.pipelineId === activeTabId;
              const runState = getRunState(tab.pipelineId);

              // For the requested pipeline, use loader data
              // For other tabs, need to lazy load (will be null on first render)
              const initialData = tab.pipelineId === requestedId
                ? requestedPipeline
                : null; // Will load from store if already there

              return (
                <div
                  key={tab.pipelineId}
                  style={{ display: isActive ? 'flex' : 'none' }}
                  className="absolute inset-0 flex-col"
                >
                  <PipelineTabPanelWithAutosave
                    pipelineId={tab.pipelineId}
                    initialData={initialData}
                    agents={userAgents}
                    traits={userTraits}
                    traitsMap={traitsMap}
                    runState={runState}
                    onOpenRunDialog={() => handleOpenRunDialog(tab.pipelineId)}
                  />

                  {/* Run progress for this tab */}
                  {runState.runId && (
                    <div className="fixed bottom-4 right-4 w-96 z-50">
                      <RunProgress
                        runId={runState.runId}
                        steps={getPipeline(tab.pipelineId)?.nodes
                          .filter(n => n.type === 'agent')
                          .map(n => ({ agentId: (n.data as any).agentId, agentName: (n.data as any).agentName })) || []}
                        onComplete={(final, outputs, inputs, usage, model) =>
                          handleRunComplete(tab.pipelineId, final, outputs, inputs, usage, model)}
                        onError={(err) => handleRunError(tab.pipelineId, err)}
                      />
                    </div>
                  )}
                </div>
              );
            })}

            {/* Empty state when no tabs */}
            {tabs.length === 0 && (
              <div className="flex items-center justify-center h-full text-muted-foreground">
                Open a pipeline from the list or create a new one
              </div>
            )}
          </div>
        </TraitsContext.Provider>
      </div>

      {/* Output viewer modals */}
      {Array.from(completedOutputs.entries()).map(([pipelineId, output]) => (
        <div key={pipelineId} className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="w-full max-w-4xl mx-4">
            <OutputViewer
              steps={output.steps}
              finalOutput={output.finalOutput}
              pipelineName={getPipeline(pipelineId)?.pipelineName || 'Pipeline'}
              usage={output.usage}
              model={output.model}
              onClose={() => setCompletedOutputs(prev => {
                const next = new Map(prev);
                next.delete(pipelineId);
                return next;
              })}
            />
          </div>
        </div>
      ))}

      {/* Run input dialog */}
      <Dialog open={!!runDialogPipelineId} onOpenChange={(open) => !open && setRunDialogPipelineId(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Run Pipeline</DialogTitle>
            <DialogDescription>
              Enter the input text for this pipeline run.
            </DialogDescription>
          </DialogHeader>
          <Textarea
            placeholder="Enter your input here..."
            value={runInput}
            onChange={(e) => setRunInput(e.target.value)}
            rows={6}
            className="resize-none"
          />
          <DialogFooter>
            <Button variant="outline" onClick={() => setRunDialogPipelineId(null)}>
              Cancel
            </Button>
            <Button onClick={handleRunSubmit}>
              <Play className="size-4 mr-2" />
              Run Pipeline
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// Wrapper that adds autosave to each tab panel
function PipelineTabPanelWithAutosave(props: {
  pipelineId: string;
  initialData: any;
  agents: any[];
  traits: any[];
  traitsMap: Map<string, any>;
  runState: { runId: string | null; isStarting: boolean };
  onOpenRunDialog: () => void;
}) {
  // Autosave for this pipeline
  useAutosave(props.pipelineId);

  return (
    <PipelineTabPanel
      {...props}
      onRunStart={() => {}} // Handled by container
    />
  );
}
```

Key changes from original:
- Tab bar at top
- Sidebar shared across all tabs
- Tab panels rendered in a loop with CSS display:none
- URL sync effect to open/focus tabs
- Run state lifted to container (persists across tab switches)
- Autosave hook attached to each tab panel
  </action>
  <verify>Navigate to /pipelines/{id}, tab opens, URL and tab store stay in sync</verify>
  <done>Route acts as tab container, URL syncs with tab store, autosave runs on changes</done>
</task>

</tasks>

<verification>
1. Edit a pipeline (move node, add edge) - autosave visible in Network tab after 1 second
2. Refresh browser - tabs restored from localStorage
3. Navigate directly to /pipelines/{id} - tab opens automatically
4. Multiple tabs can be open and switch between them
5. Run state persists when switching tabs
</verification>

<success_criteria>
- Autosave debounces at 1 second, handles race conditions
- Route renders all open tabs with CSS hiding
- URL navigation syncs with tab store
- Direct URL access opens pipeline in tab
- Browser refresh restores all tabs
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/18-pipeline-tabs/18-03-SUMMARY.md`
</output>
