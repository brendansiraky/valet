---
phase: 08-agent-configuration
plan: 03
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - app/routes/agents.tsx
  - app/services/agent-runner.server.ts
autonomous: true

must_haves:
  truths:
    - "Agent loader returns agents with their assigned trait IDs"
    - "Agent loader returns user's traits for form population"
    - "Agent create/update actions persist capability, model, and trait assignments"
    - "Agent execution includes assigned trait context in system prompt"
  artifacts:
    - path: "app/routes/agents.tsx"
      provides: "Extended loader/action for agent configuration"
      contains: ["capability", "traitIds", "traitsUpdated"]
    - path: "app/services/agent-runner.server.ts"
      provides: "Trait context injection in agent execution"
      contains: "traitContext"
  key_links:
    - from: "app/routes/agents.tsx"
      to: "app/db/schema/agent-traits.ts"
      via: "database queries"
      pattern: "agentTraits"
    - from: "app/services/agent-runner.server.ts"
      to: "system prompt construction"
      via: "trait context prepending"
      pattern: "buildSystemPrompt"
---

<objective>
Extend agents route with trait loading/saving and modify agent runner to include trait context in execution.

Purpose: Complete AGNT-09 (trait assignment persistence) and AGNT-10 (trait context in execution) functionality.
Output: Full data flow from form submission to database to agent execution with trait context.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-agent-configuration/08-RESEARCH.md
@.planning/phases/08-agent-configuration/08-01-SUMMARY.md
@.planning/phases/08-agent-configuration/08-02-SUMMARY.md

@app/routes/agents.tsx
@app/services/agent-runner.server.ts
@app/db/schema/agent-traits.ts
@app/db/schema/traits.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend agents route loader and action for trait assignment</name>
  <files>app/routes/agents.tsx</files>
  <action>
Extend the agents route to handle capability, model, and trait assignment:

**1. Update imports:**
Add `agentTraits, traits` to the db import and import `inArray` from drizzle-orm.

**2. Update AgentSchema:**
```typescript
const AgentSchema = z.object({
  name: z.string().min(1, "Name is required").max(100, "Name must be 100 characters or less"),
  instructions: z.string().min(1, "Instructions are required").max(10000, "Instructions must be 10,000 characters or less"),
  capability: z.enum(["none", "search", "fetch"]).default("none"),
  model: z.string().optional().transform(val => val || null), // Empty string becomes null
});
```

**3. Update loader to return agents with traitIds and user's traits:**
```typescript
// Query agents with their trait assignments
const userAgents = await db.query.agents.findMany({
  where: eq(agents.userId, userId),
  orderBy: [desc(agents.updatedAt)],
  with: {
    agentTraits: {
      columns: { traitId: true },
    },
  },
});

// Transform to include traitIds array
const agentsWithTraitIds = userAgents.map((agent) => ({
  ...agent,
  traitIds: agent.agentTraits.map((at) => at.traitId),
}));

// Query user's traits for form population
const userTraits = await db.query.traits.findMany({
  where: eq(traits.userId, userId),
  orderBy: [desc(traits.updatedAt)],
  columns: {
    id: true,
    name: true,
  },
});

return { agents: agentsWithTraitIds, traits: userTraits };
```

**4. Update create intent:**
```typescript
if (intent === "create") {
  const traitIds = formData.getAll("traitIds") as string[];

  const result = AgentSchema.safeParse({
    name: formData.get("name"),
    instructions: formData.get("instructions"),
    capability: formData.get("capability"),
    model: formData.get("model"),
  });

  if (!result.success) {
    return data(
      { errors: result.error.flatten().fieldErrors },
      { status: 400 }
    );
  }

  // Insert agent
  const [newAgent] = await db
    .insert(agents)
    .values({
      userId,
      name: result.data.name,
      instructions: result.data.instructions,
      capability: result.data.capability,
      model: result.data.model,
    })
    .returning({ id: agents.id });

  // Insert trait assignments
  if (traitIds.length > 0) {
    await db.insert(agentTraits).values(
      traitIds.map((traitId) => ({
        agentId: newAgent.id,
        traitId,
      }))
    );
  }

  return { success: true };
}
```

**5. Update update intent:**
```typescript
if (intent === "update") {
  const agentId = formData.get("agentId") as string;
  const traitsUpdated = formData.has("traitsUpdated");
  const traitIds = formData.getAll("traitIds") as string[];

  const result = AgentSchema.safeParse({
    name: formData.get("name"),
    instructions: formData.get("instructions"),
    capability: formData.get("capability"),
    model: formData.get("model"),
  });

  if (!result.success) {
    return data(
      { errors: result.error.flatten().fieldErrors },
      { status: 400 }
    );
  }

  // Update agent fields
  await db
    .update(agents)
    .set({
      name: result.data.name,
      instructions: result.data.instructions,
      capability: result.data.capability,
      model: result.data.model,
    })
    .where(and(eq(agents.id, agentId), eq(agents.userId, userId)));

  // Update trait assignments if traits section was submitted
  if (traitsUpdated) {
    // Delete existing assignments
    await db.delete(agentTraits).where(eq(agentTraits.agentId, agentId));

    // Insert new assignments
    if (traitIds.length > 0) {
      await db.insert(agentTraits).values(
        traitIds.map((traitId) => ({
          agentId,
          traitId,
        }))
      );
    }
  }

  return { success: true };
}
```

**6. Update component to pass traits to AgentFormDialog:**
```typescript
const { agents: userAgents, traits: userTraits } = useLoaderData<typeof loader>();

// In JSX, pass traits to AgentFormDialog:
<AgentFormDialog
  traits={userTraits}
  trigger={...}
/>

// And for edit dialog in AgentCard, pass agent with all fields:
<AgentCard
  key={agent.id}
  agent={agent}
  traits={userTraits}
  onTest={() => setTestingAgent({ id: agent.id, name: agent.name })}
/>
```

**7. Update AgentCard to accept and pass traits to edit dialog:**
If AgentCard renders the edit AgentFormDialog, it needs to accept traits prop and pass it through. Check agent-card.tsx and update accordingly.
  </action>
  <verify>TypeScript compiles: `cd /Users/brendan/code/valet && npx tsc --noEmit`</verify>
  <done>agents.tsx loader returns agents with traitIds and user's traits; create/update actions persist capability, model, and trait assignments</done>
</task>

<task type="auto">
  <name>Task 2: Modify agent runner to include trait context in execution</name>
  <files>app/services/agent-runner.server.ts</files>
  <action>
Update agent runner to accept and include trait context in the system prompt:

**1. Update AgentRunParams interface:**
```typescript
export interface AgentRunParams {
  agent: Agent;
  userInput: string;
  encryptedApiKey: string;
  model: ModelId;
  capabilities?: {
    webSearch?: boolean;
    urlFetch?: boolean;
  };
  traitContext?: string; // NEW: Combined trait context to prepend to instructions
}
```

**2. Add helper function to build system prompt:**
```typescript
function buildSystemPrompt(instructions: string, traitContext?: string): string {
  if (!traitContext) return instructions;

  // Prepend trait context to instructions with separator
  return `${traitContext}\n\n---\n\n${instructions}`;
}
```

**3. Update runAgent to use buildSystemPrompt:**
Replace direct usage of `agent.instructions` with `buildSystemPrompt(agent.instructions, traitContext)`:

```typescript
export async function runAgent(
  params: AgentRunParams
): Promise<AgentRunResult> {
  const { agent, userInput, encryptedApiKey, model, capabilities, traitContext } = params;

  try {
    const client = createAnthropicClient(encryptedApiKey);
    const systemPrompt = buildSystemPrompt(agent.instructions, traitContext);

    if (capabilities?.webSearch) {
      const result = await runWithWebSearch({
        client,
        model,
        systemPrompt, // Use built prompt
        userInput,
      });
      // ... rest unchanged
    }

    if (capabilities?.urlFetch) {
      const result = await runWithUrlFetch({
        client,
        model,
        systemPrompt, // Use built prompt
        userInput,
      });
      // ... rest unchanged
    }

    // Default: text generation only
    const result = await generateText({
      client,
      model,
      systemPrompt, // Use built prompt
      messages: [{ role: "user", content: userInput }],
    });
    // ... rest unchanged
  } catch (error) {
    // ... error handling unchanged
  }
}
```

Note: The actual loading of trait context from the database happens at the call site (API route or pipeline executor), not in the agent runner. The runner just receives the pre-built traitContext string.
  </action>
  <verify>TypeScript compiles: `cd /Users/brendan/code/valet && npx tsc --noEmit`</verify>
  <done>agent-runner.server.ts accepts traitContext parameter and includes it in system prompt via buildSystemPrompt helper</done>
</task>

<task type="auto">
  <name>Task 3: Update agent test API route to use agent configuration</name>
  <files>app/routes/api.agent.$agentId.run.ts</files>
  <action>
Update the agent run API route to:
1. Use agent's capability setting instead of form input
2. Use agent's model setting (fall back to user's default)
3. Load and include assigned trait context

Read the current api.agent.$agentId.run.ts file first to understand its structure.

**Key changes:**

1. Load agent with full fields (including capability, model):
```typescript
const agent = await db.query.agents.findFirst({
  where: and(eq(agents.id, agentId), eq(agents.userId, userId)),
});
```

2. Load trait context if agent has assigned traits:
```typescript
// Load trait context for this agent
const assignments = await db.query.agentTraits.findMany({
  where: eq(agentTraits.agentId, agentId),
  with: {
    trait: {
      columns: { name: true, context: true },
    },
  },
});

const traitContext = assignments.length > 0
  ? assignments
      .map((a) => `## ${a.trait.name}\n\n${a.trait.context}`)
      .join("\n\n---\n\n")
  : undefined;
```

3. Determine model to use:
```typescript
// Use agent's model if set, otherwise user's default
const modelToUse = (agent.model ?? user.selectedModel) as ModelId;
```

4. Determine capabilities from agent setting:
```typescript
const capabilities = {
  webSearch: agent.capability === "search",
  urlFetch: agent.capability === "fetch",
};
```

5. Pass traitContext to runAgent:
```typescript
const result = await runAgent({
  agent,
  userInput: prompt,
  encryptedApiKey: user.encryptedApiKey,
  model: modelToUse,
  capabilities,
  traitContext,
});
```

Note: The capability selector in the test dialog (if any) should be removed or ignored since capability is now on the agent definition. This will be addressed in Phase 10 (Agent UX).
  </action>
  <verify>TypeScript compiles: `cd /Users/brendan/code/valet && npx tsc --noEmit`</verify>
  <done>api.agent.$agentId.run.ts uses agent's capability and model settings, loads and includes trait context in agent execution</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Test full flow:
   - Create agent with capability=search, select a model, assign traits
   - Edit agent, change settings, verify persistence
   - Test agent, verify capability and trait context are used
3. Verify trait context appears in agent execution (check response or logs)
</verification>

<success_criteria>
- Agents loader returns agents with traitIds array and user's traits list
- Create/update actions persist capability, model, and trait assignments
- Agent runner accepts traitContext and prepends to system prompt
- API route uses agent's capability/model and loads trait context for execution
- Removing all traits from agent clears assignments (traitsUpdated marker)
</success_criteria>

<output>
After completion, create `.planning/phases/08-agent-configuration/08-03-SUMMARY.md`
</output>
