---
phase: 03-agent-capabilities
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - app/routes/api.agent.$agentId.run.ts
  - app/components/agent-test-dialog.tsx
  - app/routes/agents.tsx
autonomous: false

must_haves:
  truths:
    - "User can run an agent from the agents page"
    - "User can select which capability to use (text, search, fetch)"
    - "User sees agent response with citations if applicable"
  artifacts:
    - path: "app/routes/api.agent.$agentId.run.ts"
      provides: "API endpoint to execute an agent"
      exports: ["action"]
    - path: "app/components/agent-test-dialog.tsx"
      provides: "Dialog UI for testing agents"
      exports: ["AgentTestDialog"]
  key_links:
    - from: "app/components/agent-test-dialog.tsx"
      to: "app/routes/api.agent.$agentId.run.ts"
      via: "fetcher POST to /api/agent/:id/run"
      pattern: "fetcher\\.submit.*api/agent"
    - from: "app/routes/api.agent.$agentId.run.ts"
      to: "app/services/agent-runner.server.ts"
      via: "import and call runAgent"
      pattern: "import.*runAgent.*from.*agent-runner"
---

<objective>
Create the agent execution API and testing UI so users can run agents.

Purpose: Exposes the capabilities built in Plans 01-02 through an API endpoint and provides a UI for users to test their agents with different capabilities.

Output:
- API route that executes an agent with selected capability
- Test dialog component for running agents from the UI
- Integration into agents page
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-agent-capabilities/03-RESEARCH.md
@.planning/phases/03-agent-capabilities/03-01-SUMMARY.md
@.planning/phases/03-agent-capabilities/03-02-SUMMARY.md
@app/services/agent-runner.server.ts
@app/routes/agents.tsx
@app/db/schema/agents.ts
@app/db/schema/api-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent execution API route</name>
  <files>app/routes/api.agent.$agentId.run.ts</files>
  <action>
Create API route for executing an agent.

Route path: POST /api/agent/:agentId/run

Request body (JSON):
```typescript
{
  input: string;           // User's input/prompt
  capability?: "text" | "search" | "fetch";  // Default: "text"
}
```

Response (JSON):
```typescript
{
  success: boolean;
  content?: string;
  citations?: Array<{ url: string; title?: string }>;
  usage?: { inputTokens: number; outputTokens: number };
  error?: string;
}
```

Implementation:
1. Require authentication (use authenticator.isAuthenticated from remix-auth)
2. Parse agentId from params
3. Fetch agent from database, verify ownership (agent.userId === user.id)
4. Fetch user's API key from database (must have one configured)
5. If no API key, return error: "Please configure your API key in settings"
6. Parse request body, validate input is non-empty string
7. Map capability to flags:
   - "text" (default): { webSearch: false, urlFetch: false }
   - "search": { webSearch: true }
   - "fetch": { urlFetch: true }
8. Call runAgent with agent, input, encryptedApiKey, model (use user's selected model or default), capabilities
9. Return result as JSON

Remember to add route to app/routes.ts:
```typescript
route("api/agent/:agentId/run", "routes/api.agent.$agentId.run.ts")
```
  </action>
  <verify>
1. `npm run typecheck` passes
2. Route added to routes.ts
  </verify>
  <done>POST /api/agent/:agentId/run endpoint accepts input and capability, executes agent, returns result.</done>
</task>

<task type="auto">
  <name>Task 2: Create agent test dialog component</name>
  <files>app/components/agent-test-dialog.tsx</files>
  <action>
Create a dialog component for testing agents.

```typescript
// app/components/agent-test-dialog.tsx
interface AgentTestDialogProps {
  agent: Agent;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function AgentTestDialog({ agent, open, onOpenChange }: AgentTestDialogProps)
```

UI structure:
1. Dialog with title "Test Agent: {agent.name}"
2. Textarea for user input (placeholder: "Enter your prompt...")
3. RadioGroup for capability selection:
   - "Text only" (value: "text", default)
   - "Web search" (value: "search")
   - "URL fetch" (value: "fetch")
4. Submit button "Run Agent" (disabled while loading)
5. Response area (shown after execution):
   - Content displayed in a prose-styled div
   - Citations list if present (links with titles)
   - Token usage summary (small text)
   - Error message in red if failed

Use useFetcher to POST to /api/agent/{agent.id}/run:
```typescript
const fetcher = useFetcher<AgentRunResult>();

function handleSubmit() {
  fetcher.submit(
    { input, capability },
    { method: "POST", action: `/api/agent/${agent.id}/run`, encType: "application/json" }
  );
}
```

Show loading state while fetcher.state === "submitting".
  </action>
  <verify>TypeScript compiles: `npm run typecheck`</verify>
  <done>AgentTestDialog allows users to input prompt, select capability, run agent, and view results with citations.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate test button into agents page</name>
  <files>app/routes/agents.tsx, app/components/agent-card.tsx</files>
  <action>
Add a "Test" button to each agent card that opens the test dialog.

In agent-card.tsx:
1. Add Play icon from lucide-react (for test button)
2. Add testAgent prop callback: `onTest?: () => void`
3. Add Test button next to Edit button:
   ```tsx
   <Button variant="ghost" size="icon" onClick={onTest}>
     <Play className="h-4 w-4" />
   </Button>
   ```

In agents.tsx:
1. Import AgentTestDialog
2. Add state for which agent is being tested:
   ```typescript
   const [testingAgent, setTestingAgent] = useState<Agent | null>(null);
   ```
3. Pass onTest callback to each AgentCard:
   ```tsx
   <AgentCard agent={agent} onTest={() => setTestingAgent(agent)} ... />
   ```
4. Render AgentTestDialog at bottom of component:
   ```tsx
   {testingAgent && (
     <AgentTestDialog
       agent={testingAgent}
       open={!!testingAgent}
       onOpenChange={(open) => !open && setTestingAgent(null)}
     />
   )}
   ```
  </action>
  <verify>
1. TypeScript compiles: `npm run typecheck`
2. Dev server runs: `npm run dev`
  </verify>
  <done>Each agent card has a Test button that opens the test dialog.</done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- `npm run dev` runs without errors
- All routes registered in routes.ts
- Test dialog opens from agent card
</verification>

<success_criteria>
- User can click Test button on any agent card
- Dialog allows entering prompt and selecting capability
- Submitting runs the agent and displays response
- Citations shown when using search or fetch capabilities
- Errors displayed clearly if execution fails
</success_criteria>

<checkpoint type="human-verify" gate="blocking">
  <what-built>Agent testing UI - ability to run agents with text, search, or fetch capabilities</what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Log in and go to /agents
3. Create an agent if none exist (e.g., "Research Assistant" with instructions "You help research topics")
4. Click the Play/Test button on an agent card
5. In the dialog:
   a. Enter a simple prompt like "What is TypeScript?" with "Text only" selected
   b. Click "Run Agent" - should see Claude's response
   c. Enter "What are the latest TypeScript 5.7 features?" with "Web search" selected
   d. Click "Run Agent" - should see response with citations
   e. Enter "Summarize https://www.typescriptlang.org/docs/" with "URL fetch" selected
   f. Click "Run Agent" - should see summary with citations
6. Verify errors show properly (e.g., if no API key configured)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</checkpoint>

<output>
After completion, create `.planning/phases/03-agent-capabilities/03-03-SUMMARY.md`
</output>
