---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/services/session.server.ts
  - app/services/password.server.ts
  - app/services/encryption.server.ts
  - app/services/auth.server.ts
autonomous: true

must_haves:
  truths:
    - "Passwords can be hashed and verified using Argon2id"
    - "API keys can be encrypted and decrypted with AES-256-GCM"
    - "Sessions persist to database and can be retrieved"
    - "Authenticator validates credentials against database"
  artifacts:
    - path: "app/services/session.server.ts"
      provides: "Database-backed session storage"
      exports: ["sessionStorage", "getSession", "commitSession", "destroySession"]
    - path: "app/services/password.server.ts"
      provides: "Argon2id password hashing"
      exports: ["hashPassword", "verifyPassword"]
    - path: "app/services/encryption.server.ts"
      provides: "AES-256-GCM encryption for API keys"
      exports: ["encrypt", "decrypt"]
    - path: "app/services/auth.server.ts"
      provides: "remix-auth Authenticator with FormStrategy"
      exports: ["authenticator", "AuthUser"]
  key_links:
    - from: "app/services/auth.server.ts"
      to: "app/services/session.server.ts"
      via: "session storage import"
      pattern: "import.*session\\.server"
    - from: "app/services/auth.server.ts"
      to: "app/services/password.server.ts"
      via: "password verification"
      pattern: "verifyPassword"
    - from: "app/services/auth.server.ts"
      to: "app/db/schema/users.ts"
      via: "user lookup"
      pattern: "users"
---

<objective>
Create the core authentication services: session storage, password hashing, API key encryption, and the remix-auth authenticator.

Purpose: These services are the security foundation - all auth routes and API key management depend on them working correctly.
Output: Four server-side services ready to be used by auth routes in the next plan.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session storage and password services</name>
  <files>
    app/services/session.server.ts
    app/services/password.server.ts
  </files>
  <action>
Create app/services/session.server.ts implementing database-backed sessions using Remix's createSessionStorage.

Follow the RESEARCH.md Pattern 1 exactly:
- Cookie name: "__session"
- httpOnly: true, path: "/", sameSite: "lax"
- secrets array from process.env.SESSION_SECRET (support rotation by splitting on comma)
- secure: true only in production
- createData: Insert into sessions table, return session.id
- readData: Query sessions table by id, parse JSON data
- updateData: Update sessions table data and expiresAt
- deleteData: Delete from sessions table

Export sessionStorage, getSession, commitSession, destroySession.

Create app/services/password.server.ts implementing Argon2id hashing:
```typescript
import argon2 from "argon2";

export async function hashPassword(password: string): Promise<string> {
  return argon2.hash(password, {
    type: argon2.argon2id,
    memoryCost: 65536,    // 64 MB
    timeCost: 3,          // 3 iterations
    parallelism: 4,       // 4 threads
  });
}

export async function verifyPassword(
  password: string,
  hash: string
): Promise<boolean> {
  try {
    return await argon2.verify(hash, password);
  } catch {
    return false;
  }
}
```

IMPORTANT: Use .server.ts suffix to ensure these never leak to client bundles.
  </action>
  <verify>
Create a simple test script or use Remix action to verify:
1. hashPassword("test123") returns a string starting with "$argon2id$"
2. verifyPassword("test123", hash) returns true
3. verifyPassword("wrong", hash) returns false
4. Session can be created, read, and destroyed via sessionStorage methods

TypeScript compiles without errors.
  </verify>
  <done>
Session storage creates/reads/updates/deletes sessions in database. Password hashing produces valid Argon2id hashes. Password verification correctly validates and rejects passwords.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create encryption service and auth authenticator</name>
  <files>
    app/services/encryption.server.ts
    app/services/auth.server.ts
  </files>
  <action>
Create app/services/encryption.server.ts implementing AES-256-GCM encryption.

Follow RESEARCH.md Pattern 3 exactly:
```typescript
import crypto from "crypto";

const ALGORITHM = "aes-256-gcm";
const IV_LENGTH = 12; // 96 bits per NIST recommendation
const AUTH_TAG_LENGTH = 16;

const getKey = () => Buffer.from(process.env.ENCRYPTION_KEY!, "hex");

export function encrypt(plaintext: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, getKey(), iv);

  let encrypted = cipher.update(plaintext, "utf8", "base64");
  encrypted += cipher.final("base64");

  const authTag = cipher.getAuthTag();

  // Combine IV + authTag + ciphertext for storage
  return Buffer.concat([iv, authTag, Buffer.from(encrypted, "base64")])
    .toString("base64");
}

export function decrypt(encryptedData: string): string {
  const data = Buffer.from(encryptedData, "base64");

  const iv = data.subarray(0, IV_LENGTH);
  const authTag = data.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
  const ciphertext = data.subarray(IV_LENGTH + AUTH_TAG_LENGTH);

  const decipher = crypto.createDecipheriv(ALGORITHM, getKey(), iv);
  decipher.setAuthTag(authTag);

  let decrypted = decipher.update(ciphertext.toString("base64"), "base64", "utf8");
  decrypted += decipher.final("utf8");

  return decrypted;
}
```

Create app/services/auth.server.ts implementing remix-auth with FormStrategy.

Follow RESEARCH.md Pattern 2:
```typescript
import { Authenticator } from "remix-auth";
import { FormStrategy } from "remix-auth-form";
import { verifyPassword } from "./password.server";
import { db } from "~/db";
import { users } from "~/db/schema/users";
import { eq } from "drizzle-orm";

export type AuthUser = {
  id: string;
  email: string;
};

export const authenticator = new Authenticator<AuthUser>();

authenticator.use(
  new FormStrategy(async ({ form }) => {
    const email = form.get("email") as string;
    const password = form.get("password") as string;

    if (!email || !password) {
      throw new Error("Email and password are required");
    }

    const user = await db.query.users.findFirst({
      where: eq(users.email, email.toLowerCase()),
    });

    if (!user) {
      throw new Error("Invalid credentials");
    }

    const isValid = await verifyPassword(password, user.passwordHash);
    if (!isValid) {
      throw new Error("Invalid credentials");
    }

    return { id: user.id, email: user.email };
  }),
  "user-pass"
);
```

IMPORTANT:
- Never return specific "user not found" vs "wrong password" - always "Invalid credentials" to prevent enumeration
- Lowercase email for consistency before lookup
- AuthUser type only includes safe fields (no passwordHash)
  </action>
  <verify>
1. encrypt("sk-test-key") returns a base64 string
2. decrypt(encrypt("sk-test-key")) returns "sk-test-key"
3. Modifying encrypted data throws (auth tag verification fails)
4. TypeScript compiles auth.server.ts without errors
5. Authenticator exports properly typed AuthUser
  </verify>
  <done>
Encryption service correctly encrypts/decrypts with AES-256-GCM and detects tampering. Authenticator configured with FormStrategy, ready to validate credentials against database.
  </done>
</task>

</tasks>

<verification>
1. All four service files exist in app/services/
2. Each file has .server.ts suffix
3. TypeScript compilation passes
4. Manual test of password hash/verify cycle works
5. Manual test of encrypt/decrypt cycle works
6. Authenticator instantiates without errors
</verification>

<success_criteria>
- hashPassword produces Argon2id hashes ($argon2id$ prefix)
- verifyPassword correctly validates passwords
- encrypt/decrypt round-trips data correctly
- Tampering with encrypted data causes decryption to fail
- Authenticator ready for use in login/register routes
- All services export correct types
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
