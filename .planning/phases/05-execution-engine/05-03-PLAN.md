---
phase: 05-execution-engine
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - app/components/pipeline-runner/run-progress.tsx
  - app/components/pipeline-runner/use-run-stream.ts
  - app/routes/pipelines.$id.tsx
autonomous: false

must_haves:
  truths:
    - "User sees which agent is currently running"
    - "User sees streaming text output as agent responds"
    - "User sees error messages when execution fails"
    - "Run button triggers pipeline execution with variables"
  artifacts:
    - path: "app/components/pipeline-runner/run-progress.tsx"
      provides: "Real-time progress display component"
      min_lines: 80
    - path: "app/components/pipeline-runner/use-run-stream.ts"
      provides: "Custom hook for SSE consumption"
      exports: ["useRunStream"]
    - path: "app/routes/pipelines.$id.tsx"
      provides: "Pipeline page with execution integration"
      contains: "RunProgress"
  key_links:
    - from: "app/components/pipeline-runner/use-run-stream.ts"
      to: "/api/pipeline/run/:runId/stream"
      via: "useEventSource hook"
      pattern: "useEventSource.*api/pipeline/run"
    - from: "app/routes/pipelines.$id.tsx"
      to: "/api/pipeline/:pipelineId/run"
      via: "fetch POST to start run"
      pattern: "fetch.*api/pipeline.*run"
    - from: "app/components/pipeline-runner/run-progress.tsx"
      to: "app/components/pipeline-runner/use-run-stream.ts"
      via: "useRunStream hook"
      pattern: "useRunStream"
---

<objective>
Build the progress UI that shows real-time pipeline execution status and wire the Run button to trigger execution with template variables.

Purpose: This completes the execution engine by providing visual feedback during pipeline runs.
Output: Run progress component with streaming updates, integrated into pipeline builder page.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-execution-engine/05-RESEARCH.md
@.planning/phases/05-execution-engine/05-01-SUMMARY.md
@.planning/phases/05-execution-engine/05-02-SUMMARY.md

@app/routes/pipelines.$id.tsx
@app/services/run-emitter.server.ts
@app/stores/pipeline-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRunStream hook for SSE consumption</name>
  <files>app/components/pipeline-runner/use-run-stream.ts</files>
  <action>
Create a custom hook that consumes the SSE endpoint and manages streaming state.

Create `app/components/pipeline-runner/` directory if it doesn't exist.

In `app/components/pipeline-runner/use-run-stream.ts`:
1. Import useEventSource from 'remix-utils/sse/react'
2. Import useState, useEffect, useCallback from 'react'

3. Define event types matching RunEvent from server:
   ```typescript
   export type StreamEvent =
     | { type: 'step_start'; stepIndex: number; agentName: string }
     | { type: 'text_delta'; stepIndex: number; text: string }
     | { type: 'step_complete'; stepIndex: number; output: string }
     | { type: 'pipeline_complete'; finalOutput: string }
     | { type: 'error'; stepIndex?: number; message: string }
     | { type: 'status'; status: string };

   export interface RunStreamState {
     status: 'idle' | 'connecting' | 'running' | 'completed' | 'failed';
     currentStep: number;
     currentAgentName: string;
     streamingText: string;
     stepOutputs: Map<number, string>;
     finalOutput: string | null;
     error: string | null;
   }
   ```

4. Implement useRunStream hook:
   ```typescript
   export function useRunStream(runId: string | null) {
     const [state, setState] = useState<RunStreamState>({
       status: 'idle',
       currentStep: -1,
       currentAgentName: '',
       streamingText: '',
       stepOutputs: new Map(),
       finalOutput: null,
       error: null,
     });

     const lastEvent = useEventSource(
       runId ? `/api/pipeline/run/${runId}/stream` : null,
       { event: 'update' }
     );

     useEffect(() => {
       if (runId && state.status === 'idle') {
         setState(prev => ({ ...prev, status: 'connecting' }));
       }
     }, [runId, state.status]);

     useEffect(() => {
       if (!lastEvent) return;

       try {
         const event: StreamEvent = JSON.parse(lastEvent);

         setState(prev => {
           switch (event.type) {
             case 'step_start':
               return {
                 ...prev,
                 status: 'running',
                 currentStep: event.stepIndex,
                 currentAgentName: event.agentName,
                 streamingText: '',
               };
             case 'text_delta':
               return {
                 ...prev,
                 streamingText: prev.streamingText + event.text,
               };
             case 'step_complete':
               const newOutputs = new Map(prev.stepOutputs);
               newOutputs.set(event.stepIndex, event.output);
               return {
                 ...prev,
                 stepOutputs: newOutputs,
                 streamingText: '',
               };
             case 'pipeline_complete':
               return {
                 ...prev,
                 status: 'completed',
                 finalOutput: event.finalOutput,
                 currentStep: -1,
               };
             case 'error':
               return {
                 ...prev,
                 status: 'failed',
                 error: event.message,
               };
             case 'status':
               return {
                 ...prev,
                 status: event.status as RunStreamState['status'],
               };
             default:
               return prev;
           }
         });
       } catch (e) {
         console.error('Failed to parse SSE event:', e);
       }
     }, [lastEvent]);

     const reset = useCallback(() => {
       setState({
         status: 'idle',
         currentStep: -1,
         currentAgentName: '',
         streamingText: '',
         stepOutputs: new Map(),
         finalOutput: null,
         error: null,
       });
     }, []);

     return { ...state, reset };
   }
   ```
  </action>
  <verify>
`npx tsc --noEmit` passes. Hook exports useRunStream and handles all event types.
  </verify>
  <done>
useRunStream hook consumes SSE endpoint and provides real-time state updates for UI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RunProgress component</name>
  <files>app/components/pipeline-runner/run-progress.tsx</files>
  <action>
Create a component that displays pipeline execution progress with streaming output.

In `app/components/pipeline-runner/run-progress.tsx`:
1. Import dependencies:
   - React, useMemo from 'react'
   - useRunStream, RunStreamState from './use-run-stream'
   - Card, CardContent, CardHeader, CardTitle from ui/card
   - Progress from ui/progress
   - Badge from ui/badge
   - ScrollArea from ui/scroll-area
   - Loader2, CheckCircle2, XCircle, Circle from 'lucide-react'

2. Define props:
   ```typescript
   interface RunProgressProps {
     runId: string | null;
     steps: Array<{ agentId: string; agentName: string }>;
     onComplete?: (finalOutput: string) => void;
     onError?: (error: string) => void;
   }
   ```

3. Implement component:
   ```typescript
   export function RunProgress({ runId, steps, onComplete, onError }: RunProgressProps) {
     const {
       status,
       currentStep,
       currentAgentName,
       streamingText,
       stepOutputs,
       finalOutput,
       error,
     } = useRunStream(runId);

     // Calculate progress percentage
     const progress = useMemo(() => {
       if (status === 'completed') return 100;
       if (status === 'idle' || status === 'connecting') return 0;
       return Math.round((stepOutputs.size / steps.length) * 100);
     }, [status, stepOutputs.size, steps.length]);

     // Notify on completion/error
     useEffect(() => {
       if (status === 'completed' && finalOutput && onComplete) {
         onComplete(finalOutput);
       }
       if (status === 'failed' && error && onError) {
         onError(error);
       }
     }, [status, finalOutput, error, onComplete, onError]);

     if (!runId) return null;

     return (
       <Card className="w-full">
         <CardHeader className="pb-3">
           <div className="flex items-center justify-between">
             <CardTitle className="text-lg">Pipeline Execution</CardTitle>
             <StatusBadge status={status} />
           </div>
           <Progress value={progress} className="mt-2" />
         </CardHeader>
         <CardContent>
           {/* Step list */}
           <div className="space-y-2 mb-4">
             {steps.map((step, index) => (
               <StepRow
                 key={step.agentId}
                 index={index}
                 agentName={step.agentName}
                 status={getStepStatus(index, currentStep, stepOutputs, status)}
                 isCurrent={index === currentStep}
               />
             ))}
           </div>

           {/* Streaming output */}
           {status === 'running' && streamingText && (
             <div className="border rounded-lg p-3 bg-muted/50">
               <p className="text-sm font-medium mb-2">
                 {currentAgentName} is responding...
               </p>
               <ScrollArea className="h-48">
                 <pre className="text-sm whitespace-pre-wrap font-mono">
                   {streamingText}
                 </pre>
               </ScrollArea>
             </div>
           )}

           {/* Error display */}
           {status === 'failed' && error && (
             <div className="border border-destructive rounded-lg p-3 bg-destructive/10">
               <p className="text-sm font-medium text-destructive">Error</p>
               <p className="text-sm text-destructive/80">{error}</p>
             </div>
           )}

           {/* Completion message */}
           {status === 'completed' && (
             <div className="border border-green-500 rounded-lg p-3 bg-green-500/10">
               <p className="text-sm font-medium text-green-700 dark:text-green-400">
                 Pipeline completed successfully
               </p>
             </div>
           )}
         </CardContent>
       </Card>
     );
   }

   // Helper components
   function StatusBadge({ status }: { status: RunStreamState['status'] }) {
     const variants: Record<string, { label: string; variant: 'default' | 'secondary' | 'destructive' | 'outline' }> = {
       idle: { label: 'Idle', variant: 'outline' },
       connecting: { label: 'Connecting...', variant: 'secondary' },
       running: { label: 'Running', variant: 'default' },
       completed: { label: 'Completed', variant: 'default' },
       failed: { label: 'Failed', variant: 'destructive' },
     };
     const { label, variant } = variants[status] || variants.idle;
     return <Badge variant={variant}>{label}</Badge>;
   }

   function StepRow({
     index,
     agentName,
     status,
     isCurrent,
   }: {
     index: number;
     agentName: string;
     status: 'pending' | 'running' | 'completed' | 'failed';
     isCurrent: boolean;
   }) {
     return (
       <div className={`flex items-center gap-2 p-2 rounded ${isCurrent ? 'bg-muted' : ''}`}>
         {status === 'pending' && <Circle className="w-4 h-4 text-muted-foreground" />}
         {status === 'running' && <Loader2 className="w-4 h-4 animate-spin text-primary" />}
         {status === 'completed' && <CheckCircle2 className="w-4 h-4 text-green-500" />}
         {status === 'failed' && <XCircle className="w-4 h-4 text-destructive" />}
         <span className="text-sm">{index + 1}. {agentName}</span>
       </div>
     );
   }

   function getStepStatus(
     index: number,
     currentStep: number,
     stepOutputs: Map<number, string>,
     runStatus: RunStreamState['status']
   ): 'pending' | 'running' | 'completed' | 'failed' {
     if (stepOutputs.has(index)) return 'completed';
     if (index === currentStep) {
       return runStatus === 'failed' ? 'failed' : 'running';
     }
     return 'pending';
   }
   ```

Import useEffect at top of file.
  </action>
  <verify>
`npx tsc --noEmit` passes. Component renders step list, streaming output, and status badges.
  </verify>
  <done>
RunProgress component shows real-time execution with step indicators, streaming text, and error display.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire Run button to execution in pipeline page</name>
  <files>app/routes/pipelines.$id.tsx</files>
  <action>
Integrate the RunProgress component and connect the Run button to start pipeline execution.

Modify `app/routes/pipelines.$id.tsx`:

1. Add imports at top:
   ```typescript
   import { RunProgress } from '~/components/pipeline-runner/run-progress';
   ```

2. Add state for run tracking:
   ```typescript
   const [currentRunId, setCurrentRunId] = useState<string | null>(null);
   const [isStartingRun, setIsStartingRun] = useState(false);
   ```

3. Replace handleRun function:
   ```typescript
   const handleRun = async () => {
     if (templateVariables.length > 0) {
       setVariableFillDialogOpen(true);
     } else {
       await startPipelineRun('');
     }
   };
   ```

4. Replace handleRunWithVariables function:
   ```typescript
   const handleRunWithVariables = async (values: Record<string, string>) => {
     // Substitute variables in initial input if needed
     // For now, pass empty input - first agent uses its instructions
     await startPipelineRun('', values);
   };
   ```

5. Add startPipelineRun function:
   ```typescript
   const startPipelineRun = async (input: string, variables?: Record<string, string>) => {
     if (!pipelineId) return;

     setIsStartingRun(true);
     try {
       const formData = new FormData();
       formData.set('input', input);
       if (variables) {
         formData.set('variables', JSON.stringify(variables));
       }

       const response = await fetch(`/api/pipeline/${pipelineId}/run`, {
         method: 'POST',
         body: formData,
       });

       const data = await response.json();
       if (data.error) {
         throw new Error(data.error);
       }

       setCurrentRunId(data.runId);
       setVariableFillDialogOpen(false);
     } catch (error) {
       console.error('Failed to start pipeline:', error);
       // TODO: Show toast error
     } finally {
       setIsStartingRun(false);
     }
   };
   ```

6. Add helper to get steps from store nodes:
   ```typescript
   const pipelineSteps = useMemo(() => {
     return nodes.map(node => ({
       agentId: node.data.agentId,
       agentName: node.data.agentName,
     }));
   }, [nodes]);
   ```

7. Add handleRunComplete and handleRunError callbacks:
   ```typescript
   const handleRunComplete = useCallback((finalOutput: string) => {
     console.log('Pipeline completed:', finalOutput);
     // Phase 6 will add output viewing
   }, []);

   const handleRunError = useCallback((error: string) => {
     console.error('Pipeline failed:', error);
     // TODO: Show toast error
   }, []);
   ```

8. Update the Run button to show loading state:
   ```typescript
   <Button onClick={handleRun} disabled={isStartingRun || !!currentRunId}>
     {isStartingRun ? (
       <>
         <Loader2 className="w-4 h-4 mr-2 animate-spin" />
         Starting...
       </>
     ) : currentRunId ? (
       <>
         <Loader2 className="w-4 h-4 mr-2 animate-spin" />
         Running...
       </>
     ) : (
       <>
         <Play className="w-4 h-4 mr-2" />
         Run
       </>
     )}
   </Button>
   ```

9. Add RunProgress component below the main content (above dialogs):
   ```typescript
   {/* Run Progress */}
   {currentRunId && (
     <div className="fixed bottom-4 right-4 w-96 z-50">
       <RunProgress
         runId={currentRunId}
         steps={pipelineSteps}
         onComplete={handleRunComplete}
         onError={handleRunError}
       />
     </div>
   )}
   ```

10. Import useMemo, useCallback at top, and Loader2 from lucide-react.

11. Add button to dismiss/close the run progress after completion:
    - In RunProgress onComplete callback, don't auto-dismiss
    - User can click away or close it manually (add X button in future if needed)
  </action>
  <verify>
`npx tsc --noEmit` passes. Run button triggers execution, progress component appears.
  </verify>
  <done>
Pipeline page Run button starts execution and shows real-time progress overlay.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete pipeline execution engine with real-time streaming progress:
- Click "Run" on a pipeline with agents
- See progress overlay showing each agent step
- Watch streaming text output as agents respond
- See completion or error status
  </what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`
2. Log in and navigate to an existing pipeline with 2+ agents
3. Click the "Run" button (or fill variables first if template)
4. Verify:
   - Progress overlay appears in bottom-right
   - Current running agent shows spinner
   - Text streams in real-time as agent responds
   - Completed agents show checkmark
   - Progress bar advances
   - "Pipeline completed" message on success
5. Test error case:
   - Create a pipeline but don't save API key
   - Run should show error state with message
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. Dev server starts without errors
3. Pipeline execution triggers and streams events
4. UI updates in real-time during execution
5. Error states display correctly
</verification>

<success_criteria>
- useRunStream hook handles all SSE event types
- RunProgress component shows step status, streaming text, errors
- Run button in pipeline page triggers execution via API
- Progress overlay appears during run
- Variables are passed correctly to execution
- User can see which agent is running at any moment
- Streaming text appears token-by-token
- Errors display with clear messages
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-engine/05-03-SUMMARY.md`
</output>
