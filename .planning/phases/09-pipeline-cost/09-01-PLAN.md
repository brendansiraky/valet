---
phase: 09-pipeline-cost
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/pricing.ts
  - app/services/pipeline-executor.server.ts
  - app/services/run-emitter.server.ts
  - app/services/job-queue.server.ts
autonomous: true

must_haves:
  truths:
    - "Pipeline execution uses runWithTools (unified tools available to all agents)"
    - "Token usage is accumulated across all pipeline steps"
    - "Pipeline complete event includes usage data and model"
  artifacts:
    - path: "app/lib/pricing.ts"
      provides: "Model pricing constants and cost calculation"
      exports: ["MODEL_PRICING", "calculateCost", "formatCost", "formatTokens"]
    - path: "app/services/pipeline-executor.server.ts"
      provides: "Pipeline executor with unified tools"
      contains: "runWithTools"
    - path: "app/services/run-emitter.server.ts"
      provides: "Updated RunEvent with usage"
      contains: "usage?: { inputTokens: number; outputTokens: number }"
  key_links:
    - from: "app/services/pipeline-executor.server.ts"
      to: "app/services/capabilities/run-with-tools.server.ts"
      via: "import runWithTools"
      pattern: "import.*runWithTools"
    - from: "app/services/pipeline-executor.server.ts"
      to: "app/services/run-emitter.server.ts"
      via: "emitRunEvent with usage"
      pattern: "pipeline_complete.*usage"
---

<objective>
Refactor pipeline executor to use unified tools (runWithTools) and track token usage.

Purpose: Enable pipeline agents to use web search and URL fetch (just like agent test dialog), and collect usage data for cost display.
Output: Modified executor that uses runWithTools, pricing utilities, and updated event types with usage data.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-pipeline-cost/09-RESEARCH.md

Key existing files:
@app/services/pipeline-executor.server.ts
@app/services/capabilities/run-with-tools.server.ts
@app/services/run-emitter.server.ts
@app/services/job-queue.server.ts
@app/services/agent-runner.server.ts (pattern for buildSystemPrompt and trait loading)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pricing module</name>
  <files>app/lib/pricing.ts</files>
  <action>
Create pricing utilities module with:

1. MODEL_PRICING constant with prices per million tokens:
   - claude-opus-4-5-20251101: input $5, output $25
   - claude-sonnet-4-5-20250929: input $3, output $15
   - claude-haiku-4-5-20251001: input $1, output $5

2. calculateCost(model: string, inputTokens: number, outputTokens: number): number
   - Returns cost in USD as a number
   - Falls back to Sonnet pricing if model unknown

3. formatCost(cost: number): string
   - Returns "<$0.01" if cost < 0.01
   - Otherwise returns "$X.XX" with 2 decimal places

4. formatTokens(count: number): string
   - Returns "X.XM" for millions
   - Returns "X.XK" for thousands
   - Returns raw number for <1000

Add comment with last verified date (2026-01-29) and pricing source.
  </action>
  <verify>Check file exports all four items, TypeScript compiles without errors</verify>
  <done>Pricing module exists with MODEL_PRICING, calculateCost, formatCost, formatTokens exports</done>
</task>

<task type="auto">
  <name>Task 2: Update RunEvent type and executor to use unified tools</name>
  <files>
    app/services/run-emitter.server.ts
    app/services/pipeline-executor.server.ts
    app/services/job-queue.server.ts
  </files>
  <action>
**run-emitter.server.ts:**
Update RunEvent type to add optional usage and model to pipeline_complete:
```typescript
| {
    type: "pipeline_complete";
    finalOutput: string;
    usage?: { inputTokens: number; outputTokens: number };
    model?: string;
  }
```

**pipeline-executor.server.ts:**
1. Import runWithTools from './capabilities/run-with-tools.server'
2. Add traitContext to PipelineStep interface (optional string field)
3. Create buildSystemPrompt helper (copy pattern from agent-runner.server.ts):
   - Prepends trait context to instructions with "---" separator

4. Refactor executePipeline:
   - Add usage accumulator: `{ totalInputTokens: 0, totalOutputTokens: 0 }`
   - Replace `client.messages.stream()` with `runWithTools()` call:
     ```typescript
     const result = await runWithTools({
       client,
       model,
       systemPrompt: buildSystemPrompt(substitutedInstructions, step.traitContext),
       userInput: userMessage,
     });
     ```
   - Accumulate usage after each step: add result.usage.inputTokens and outputTokens
   - Use result.content as fullOutput (no more streaming - complete response per step)
   - Remove stream.on("text") and text_delta emissions (runWithTools returns complete response)
   - Emit step_complete with result.content as output
   - Update pipeline_complete event to include usage and model:
     ```typescript
     runEmitter.emitRunEvent(runId, {
       type: "pipeline_complete",
       finalOutput: currentInput,
       usage: {
         inputTokens: usage.totalInputTokens,
         outputTokens: usage.totalOutputTokens,
       },
       model,
     });
     ```

**job-queue.server.ts:**
1. Import agentTraits from db
2. In buildStepsFromFlow, after loading each agent:
   - Load trait assignments for the agent using the same pattern as api.agent.$agentId.run.ts:
     ```typescript
     const assignments = await db.query.agentTraits.findMany({
       where: eq(agentTraits.agentId, agent.id),
       with: { trait: { columns: { name: true, context: true } } },
     });
     const traitContext = assignments.length > 0
       ? assignments.map(a => `## ${a.trait.name}\n\n${a.trait.context}`).join("\n\n---\n\n")
       : undefined;
     ```
   - Add traitContext to the PipelineStep returned
3. Pass agent.model to executePipeline for model cascade (agent.model ?? apiKey.modelPreference ?? default)

**Note on streaming:** This refactor removes per-step streaming in exchange for unified tools. The UI will see step_start, then step_complete without intermediate text_delta events. The research notes this as an acceptable tradeoff for v1.1.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
Manually verify imports are correct
  </verify>
  <done>
Pipeline executor uses runWithTools with both web_search and web_fetch available, accumulates usage across steps, and emits pipeline_complete with usage data and model
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. Pricing module exports all utilities
3. RunEvent type includes usage and model in pipeline_complete
4. Pipeline executor imports and uses runWithTools
5. Job queue loads trait context for each agent step
</verification>

<success_criteria>
- Pipeline execution uses unified tools (web_search + web_fetch available)
- Token usage accumulated and emitted in pipeline_complete event
- Model included in pipeline_complete event
- Trait context loaded and applied for each agent in pipeline
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-pipeline-cost/09-01-SUMMARY.md`
</output>
