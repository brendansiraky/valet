---
phase: 09-pipeline-cost
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - app/components/pipeline-runner/use-run-stream.ts
  - app/components/pipeline-runner/run-progress.tsx
autonomous: true

must_haves:
  truths:
    - "User sees token count after pipeline completes"
    - "User sees estimated cost after pipeline completes"
  artifacts:
    - path: "app/components/pipeline-runner/run-progress.tsx"
      provides: "Cost summary display on completion"
      contains: "formatCost"
    - path: "app/components/pipeline-runner/use-run-stream.ts"
      provides: "State for usage and model from SSE"
      contains: "usage"
  key_links:
    - from: "app/components/pipeline-runner/run-progress.tsx"
      to: "app/lib/pricing.ts"
      via: "import { calculateCost, formatCost, formatTokens }"
      pattern: "import.*pricing"
---

<objective>
Display token usage and estimated cost in the pipeline completion UI.

Purpose: Give users visibility into how much their pipeline run cost in tokens and estimated USD.
Output: Updated RunProgress component that shows usage summary when pipeline completes.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-pipeline-cost/09-RESEARCH.md
@.planning/phases/09-pipeline-cost/09-01-SUMMARY.md

Key existing files:
@app/components/pipeline-runner/use-run-stream.ts
@app/components/pipeline-runner/run-progress.tsx
@app/lib/pricing.ts (created in 09-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update use-run-stream hook to track usage</name>
  <files>app/components/pipeline-runner/use-run-stream.ts</files>
  <action>
1. Update StreamEvent type to match server RunEvent changes:
   - Add usage and model to pipeline_complete case:
     ```typescript
     | {
         type: "pipeline_complete";
         finalOutput: string;
         usage?: { inputTokens: number; outputTokens: number };
         model?: string;
       }
     ```

2. Update RunStreamState interface to include usage:
   ```typescript
   export interface RunStreamState {
     status: "idle" | "connecting" | "running" | "completed" | "failed";
     currentStep: number;
     currentAgentName: string;
     streamingText: string;
     stepOutputs: Map<number, string>;
     finalOutput: string | null;
     error: string | null;
     usage: { inputTokens: number; outputTokens: number } | null;  // NEW
     model: string | null;  // NEW
   }
   ```

3. Update initialState to include null usage and model:
   ```typescript
   usage: null,
   model: null,
   ```

4. Update pipeline_complete case handler to capture usage and model:
   ```typescript
   case "pipeline_complete":
     return {
       ...prev,
       status: "completed",
       finalOutput: event.finalOutput,
       currentStep: -1,
       usage: event.usage || null,
       model: event.model || null,
     };
   ```

5. Since we're no longer streaming (runWithTools returns complete response), the text_delta events won't come. The step_start -> step_complete flow remains valid. No changes needed for step handling.
  </action>
  <verify>TypeScript compiles, hook returns usage and model in state</verify>
  <done>useRunStream hook captures usage and model from pipeline_complete event</done>
</task>

<task type="auto">
  <name>Task 2: Display cost summary in RunProgress component</name>
  <files>app/components/pipeline-runner/run-progress.tsx</files>
  <action>
1. Import pricing utilities:
   ```typescript
   import { calculateCost, formatCost, formatTokens } from "~/lib/pricing";
   ```

2. Destructure usage and model from useRunStream:
   ```typescript
   const {
     status,
     currentStep,
     currentAgentName,
     streamingText,
     stepOutputs,
     finalOutput,
     error,
     usage,   // NEW
     model,   // NEW
   } = useRunStream(runId);
   ```

3. Update the completion section (the success div) to include a usage summary card. Replace the existing completion message with:
   ```tsx
   {status === "completed" && (
     <div className="space-y-3">
       <div className="border border-green-500 rounded-lg p-3 bg-green-500/10">
         <p className="text-sm font-medium text-green-700 dark:text-green-400">
           Pipeline completed successfully
         </p>
       </div>
       {usage && model && (
         <div className="p-3 bg-muted rounded-lg">
           <h4 className="text-sm font-medium mb-2">Usage Summary</h4>
           <div className="grid grid-cols-2 gap-2 text-sm">
             <div>
               <span className="text-muted-foreground">Input tokens:</span>
               <span className="ml-2 font-mono">{formatTokens(usage.inputTokens)}</span>
             </div>
             <div>
               <span className="text-muted-foreground">Output tokens:</span>
               <span className="ml-2 font-mono">{formatTokens(usage.outputTokens)}</span>
             </div>
             <div className="col-span-2">
               <span className="text-muted-foreground">Estimated cost:</span>
               <span className="ml-2 font-medium">
                 {formatCost(calculateCost(model, usage.inputTokens, usage.outputTokens))}
               </span>
             </div>
           </div>
         </div>
       )}
     </div>
   )}
   ```

4. The streaming text section can remain but will typically be empty since runWithTools doesn't stream. It will still show the agent name during processing. Keep it for potential future streaming support.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
Visually inspect component structure is valid JSX
  </verify>
  <done>
RunProgress displays usage summary with input tokens, output tokens, and estimated cost when pipeline completes with usage data
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. use-run-stream exports usage and model in state
3. RunProgress imports pricing utilities
4. Completion section shows usage summary when usage data available
</verification>

<success_criteria>
- User sees token counts (input and output) after pipeline completes
- User sees estimated cost formatted as "$X.XX" after pipeline completes
- Usage summary only appears when usage data is present (graceful degradation)
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-pipeline-cost/09-02-SUMMARY.md`
</output>
