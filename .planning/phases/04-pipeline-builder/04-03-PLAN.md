---
phase: 04-pipeline-builder
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - app/routes/api.pipelines.ts
  - app/routes/pipelines.$id.tsx
  - app/lib/pipeline-layout.ts
autonomous: true

must_haves:
  truths:
    - "User can save a pipeline and see it persisted"
    - "User can load a previously saved pipeline"
    - "User can delete a pipeline"
    - "Pipeline list shows saved pipelines with correct names"
  artifacts:
    - path: "app/routes/api.pipelines.ts"
      provides: "Pipeline CRUD API endpoints"
      exports: ["action"]
    - path: "app/lib/pipeline-layout.ts"
      provides: "Dagre auto-layout utility"
      exports: ["getLayoutedElements"]
  key_links:
    - from: "app/routes/pipelines.$id.tsx"
      to: "app/routes/api.pipelines.ts"
      via: "fetch to API route"
      pattern: "fetch.*api/pipelines"
    - from: "app/routes/api.pipelines.ts"
      to: "app/db/schema/pipelines.ts"
      via: "Drizzle query"
      pattern: "db\\.(insert|update|delete).*pipelines"
---

<objective>
Implement pipeline persistence: save, load, and delete pipelines via API.

Purpose: Enable users to persist their pipeline work - save progress, return later, and manage their pipeline library.
Output: Working pipeline CRUD API with save/load/delete, integrated with builder UI.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pipeline-builder/04-RESEARCH.md
@.planning/phases/04-pipeline-builder/04-01-SUMMARY.md

Reference existing API patterns:
@app/routes/agents.tsx (uses intent-based actions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dagre layout utility</name>
  <files>app/lib/pipeline-layout.ts</files>
  <action>
Create `app/lib/pipeline-layout.ts` for auto-layout functionality:

```typescript
import dagre from 'dagre';
import type { Node, Edge } from '@xyflow/react';

const NODE_WIDTH = 250;
const NODE_HEIGHT = 100;

/**
 * Applies dagre layout to position nodes in a left-to-right flow.
 * Use after adding nodes or when user clicks "Auto Layout" button.
 */
export function getLayoutedElements<T>(
  nodes: Node<T>[],
  edges: Edge[],
  direction: 'LR' | 'TB' = 'LR'
): { nodes: Node<T>[]; edges: Edge[] } {
  const dagreGraph = new dagre.graphlib.Graph();
  dagreGraph.setDefaultEdgeLabel(() => ({}));
  dagreGraph.setGraph({
    rankdir: direction,
    nodesep: 50,  // Horizontal spacing between nodes
    ranksep: 100, // Vertical spacing between ranks
  });

  // Add nodes to dagre graph
  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: NODE_WIDTH, height: NODE_HEIGHT });
  });

  // Add edges to dagre graph
  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  // Calculate layout
  dagre.layout(dagreGraph);

  // Apply calculated positions to nodes
  const layoutedNodes = nodes.map((node) => {
    const nodeWithPosition = dagreGraph.node(node.id);
    return {
      ...node,
      position: {
        x: nodeWithPosition.x - NODE_WIDTH / 2,
        y: nodeWithPosition.y - NODE_HEIGHT / 2,
      },
    };
  });

  return { nodes: layoutedNodes, edges };
}
```

This utility will be used:
1. When loading a pipeline (optional auto-layout)
2. When user clicks "Auto Layout" button
3. Optionally after dropping new nodes
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
Function exported correctly
  </verify>
  <done>Dagre layout utility created with LR/TB direction support</done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline CRUD API</name>
  <files>app/routes/api.pipelines.ts</files>
  <action>
Create `app/routes/api.pipelines.ts` with intent-based actions:

```typescript
import type { Route } from './+types/api.pipelines';
import { db } from '@/db';
import { pipelines } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { requireUser } from '@/lib/auth/session.server';

// Type for flow data
interface FlowData {
  nodes: Array<{ id: string; type: string; position: { x: number; y: number }; data: unknown }>;
  edges: Array<{ id: string; source: string; target: string }>;
  viewport?: { x: number; y: number; zoom: number };
}

export async function action({ request }: Route.ActionArgs) {
  const user = await requireUser(request);
  const formData = await request.formData();
  const intent = formData.get('intent');

  switch (intent) {
    case 'create': {
      const name = formData.get('name') as string;
      const description = formData.get('description') as string | null;
      const flowDataStr = formData.get('flowData') as string;

      if (!name) {
        return Response.json({ error: 'Name is required' }, { status: 400 });
      }

      const flowData: FlowData = flowDataStr ? JSON.parse(flowDataStr) : { nodes: [], edges: [] };

      const [newPipeline] = await db
        .insert(pipelines)
        .values({
          userId: user.id,
          name,
          description,
          flowData,
        })
        .returning();

      return Response.json({ pipeline: newPipeline });
    }

    case 'update': {
      const id = formData.get('id') as string;
      const name = formData.get('name') as string;
      const description = formData.get('description') as string | null;
      const flowDataStr = formData.get('flowData') as string;

      if (!id || !name) {
        return Response.json({ error: 'ID and name are required' }, { status: 400 });
      }

      const flowData: FlowData = JSON.parse(flowDataStr);

      const [updated] = await db
        .update(pipelines)
        .set({
          name,
          description,
          flowData,
          updatedAt: new Date(),
        })
        .where(and(eq(pipelines.id, id), eq(pipelines.userId, user.id)))
        .returning();

      if (!updated) {
        return Response.json({ error: 'Pipeline not found' }, { status: 404 });
      }

      return Response.json({ pipeline: updated });
    }

    case 'delete': {
      const id = formData.get('id') as string;

      if (!id) {
        return Response.json({ error: 'ID is required' }, { status: 400 });
      }

      const [deleted] = await db
        .delete(pipelines)
        .where(and(eq(pipelines.id, id), eq(pipelines.userId, user.id)))
        .returning();

      if (!deleted) {
        return Response.json({ error: 'Pipeline not found' }, { status: 404 });
      }

      return Response.json({ success: true });
    }

    default:
      return Response.json({ error: 'Invalid intent' }, { status: 400 });
  }
}
```

Key points:
- Uses intent-based pattern from agents.tsx
- Validates user owns pipeline before update/delete
- Returns JSON for client-side handling
- FlowData typed for safety
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
Action exports correctly
  </verify>
  <done>Pipeline CRUD API created with create/update/delete intents</done>
</task>

<task type="auto">
  <name>Task 3: Wire save/load to builder UI</name>
  <files>app/routes/pipelines.$id.tsx</files>
  <action>
Update `app/routes/pipelines.$id.tsx` to add save functionality:

1. Add save handler that calls API:
```typescript
import { useNavigate } from 'react-router';

// In component:
const navigate = useNavigate();
const [isSaving, setIsSaving] = useState(false);
const { nodes, edges, pipelineName, pipelineId } = usePipelineStore();

const handleSave = async () => {
  setIsSaving(true);
  try {
    const formData = new FormData();
    formData.set('intent', pipelineId ? 'update' : 'create');
    if (pipelineId) {
      formData.set('id', pipelineId);
    }
    formData.set('name', pipelineName);
    formData.set('description', ''); // TODO: add description input
    formData.set('flowData', JSON.stringify({ nodes, edges }));

    const response = await fetch('/api/pipelines', {
      method: 'POST',
      body: formData,
    });

    const data = await response.json();
    if (data.error) {
      throw new Error(data.error);
    }

    // If created new, navigate to the saved pipeline
    if (!pipelineId && data.pipeline) {
      navigate(`/pipelines/${data.pipeline.id}`, { replace: true });
    }
  } catch (error) {
    console.error('Failed to save pipeline:', error);
    // TODO: Show toast error
  } finally {
    setIsSaving(false);
  }
};
```

2. Update save button:
```tsx
<Button onClick={handleSave} disabled={isSaving}>
  {isSaving ? 'Saving...' : 'Save'}
</Button>
```

3. Add auto-layout button using the dagre utility:
```typescript
import { getLayoutedElements } from '@/lib/pipeline-layout';

const handleAutoLayout = () => {
  const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(nodes, edges);
  setNodes(layoutedNodes);
  setEdges(layoutedEdges);
};

// In JSX:
<Button variant="outline" onClick={handleAutoLayout}>
  Auto Layout
</Button>
```

4. Add delete functionality (for existing pipelines):
```typescript
const handleDelete = async () => {
  if (!pipelineId || !confirm('Delete this pipeline?')) return;

  const formData = new FormData();
  formData.set('intent', 'delete');
  formData.set('id', pipelineId);

  await fetch('/api/pipelines', {
    method: 'POST',
    body: formData,
  });

  navigate('/pipelines');
};

// In JSX (show only for existing pipelines):
{pipelineId && (
  <Button variant="destructive" onClick={handleDelete}>
    Delete
  </Button>
)}
```

Full updated component should include:
- useState for isSaving
- Save, Auto Layout, and Delete buttons in header
- Navigation after create
- Proper error handling
  </action>
  <verify>
1. Create new pipeline with agents, click Save - redirects to /pipelines/{id}
2. Refresh page - pipeline loads with same nodes/edges
3. Make changes, click Save - changes persist
4. Go to /pipelines list - see saved pipeline
5. Click Delete - pipeline removed, redirected to list
6. Click Auto Layout - nodes rearranged in sequence
  </verify>
  <done>Pipeline builder UI wired with save/load/delete; auto-layout working</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - no type errors
2. Create new pipeline with 2+ agents - Save creates pipeline
3. URL changes to /pipelines/{id} after save
4. Refresh - pipeline state restored
5. Make changes, save - updates persist
6. Auto Layout - nodes arranged left-to-right
7. Delete - pipeline removed
8. Pipelines list shows all saved pipelines
</verification>

<success_criteria>
- Save button creates new pipeline or updates existing
- Pipeline state (nodes, edges, name) persists to database
- Loading a pipeline restores full state
- Delete removes pipeline and redirects
- Auto Layout arranges nodes sequentially
- API validates user ownership
</success_criteria>

<output>
After completion, create `.planning/phases/04-pipeline-builder/04-03-SUMMARY.md`
</output>
