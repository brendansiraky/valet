---
phase: 11-provider-abstraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/providers/types.ts
  - app/lib/providers/registry.ts
  - app/lib/providers/anthropic.ts
  - app/lib/models.ts
  - app/lib/pricing.ts
autonomous: true

must_haves:
  truths:
    - "Provider interface exists with chat(), validateKey(), getModels() methods"
    - "Provider registry can create provider instances with API key"
    - "Anthropic provider implements the interface using existing SDK patterns"
    - "Models and pricing are organized by provider"
  artifacts:
    - path: "app/lib/providers/types.ts"
      provides: "AIProvider interface and related types"
      exports: ["AIProvider", "ChatMessage", "ChatOptions", "ChatResult", "ProviderModel", "ToolConfig"]
    - path: "app/lib/providers/registry.ts"
      provides: "Provider factory registration and instantiation"
      exports: ["registerProviderFactory", "getProvider", "getProviderForModel", "getAllProviderIds"]
    - path: "app/lib/providers/anthropic.ts"
      provides: "Anthropic provider implementation"
      exports: ["AnthropicProvider"]
    - path: "app/lib/models.ts"
      provides: "Multi-provider model definitions"
      exports: ["ANTHROPIC_MODELS", "ALL_MODELS", "ModelId"]
    - path: "app/lib/pricing.ts"
      provides: "Multi-provider pricing lookup"
      contains: "MODEL_PRICING keyed by model ID"
  key_links:
    - from: "app/lib/providers/anthropic.ts"
      to: "app/lib/providers/types.ts"
      via: "implements AIProvider"
      pattern: "implements AIProvider"
    - from: "app/lib/providers/anthropic.ts"
      to: "app/lib/models.ts"
      via: "imports ANTHROPIC_MODELS"
      pattern: "import.*ANTHROPIC_MODELS"
    - from: "app/lib/providers/registry.ts"
      to: "app/lib/providers/anthropic.ts"
      via: "factory creates AnthropicProvider instances on demand"
      pattern: "new AnthropicProvider"
---

<objective>
Create provider abstraction layer with Anthropic as first implementation.

Purpose: Enable multi-provider support (OpenAI in Phase 12) without service rewrites by abstracting AI provider operations behind a common interface.

Output: Provider types, registry, and Anthropic implementation that existing services can adopt.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-provider-abstraction/11-RESEARCH.md

# Existing files to understand
@app/lib/models.ts
@app/lib/pricing.ts
@app/services/capabilities/run-with-tools.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create provider types and interface</name>
  <files>app/lib/providers/types.ts</files>
  <action>
Create the provider interface file with these types:

1. ChatMessage - message format (role: system/user/assistant, content: string)
2. ChatOptions - model, maxTokens, tools array
3. ChatResult - content, usage (inputTokens/outputTokens), citations array
4. ToolConfig - type (web_search/web_fetch), maxUses optional
5. ProviderModel - id, name, provider string
6. AIProvider interface with:
   - readonly id: string
   - chat(messages: ChatMessage[], options: ChatOptions): Promise<ChatResult>
   - validateKey(apiKey: string): Promise<boolean>
   - getModels(): ProviderModel[]

Keep types minimal - don't over-abstract. These types should work for both Anthropic and OpenAI.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit app/lib/providers/types.ts`</verify>
  <done>Provider interface types exported and compilable</done>
</task>

<task type="auto">
  <name>Task 2a: Create provider registry with factory pattern</name>
  <files>app/lib/providers/registry.ts</files>
  <action>
Create provider registry using factory pattern (providers need API keys at construction time, so we store factories not instances):

```typescript
type ProviderFactory = (apiKey: string) => AIProvider;

const providerFactories = new Map<string, ProviderFactory>();

export function registerProviderFactory(providerId: string, factory: ProviderFactory): void {
  providerFactories.set(providerId, factory);
}

export function getProvider(providerId: string, apiKey: string): AIProvider {
  const factory = providerFactories.get(providerId);
  if (!factory) {
    throw new Error(`Unknown provider: ${providerId}`);
  }
  return factory(apiKey);
}

export function getProviderForModel(modelId: string): string {
  // claude-* models -> anthropic
  // gpt-* models -> openai (Phase 12)
  if (modelId.startsWith("claude-")) return "anthropic";
  throw new Error(`Unknown model provider: ${modelId}`);
}

export function getAllProviderIds(): string[] {
  return Array.from(providerFactories.keys());
}
```

This pattern:
- Stores lightweight factories, not instances
- Creates fresh provider instance per request with caller's API key
- Supports multiple providers without circular dependencies
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit app/lib/providers/registry.ts`</verify>
  <done>Registry exports registerProviderFactory, getProvider, getProviderForModel, getAllProviderIds</done>
</task>

<task type="auto">
  <name>Task 2b: Create Anthropic provider and register factory</name>
  <files>app/lib/providers/anthropic.ts, app/lib/models.ts, app/lib/pricing.ts</files>
  <action>
**anthropic.ts:**
Create AnthropicProvider class implementing AIProvider:
- Constructor takes apiKey string, creates Anthropic client
- `chat()` method:
  - Extract system message from messages array
  - Build Anthropic-specific tool config from ToolConfig[] (web_search_20250305, web_fetch_20250910)
  - Add beta headers for web_fetch if needed
  - Call client.messages.create()
  - Extract text content and citations from response
  - Return ChatResult with usage
- `validateKey()` method: Create test client, make minimal API call, return boolean
- `getModels()` method: Return ANTHROPIC_MODELS mapped to ProviderModel[]

At bottom of file, register the factory:
```typescript
import { registerProviderFactory } from "./registry";
registerProviderFactory("anthropic", (apiKey) => new AnthropicProvider(apiKey));
```

**models.ts:**
Expand to support multi-provider:
- Rename AVAILABLE_MODELS to ANTHROPIC_MODELS
- Add provider field to model objects: `{ id: "claude-...", name: "...", provider: "anthropic" }`
- Export ALL_MODELS (for now just ANTHROPIC_MODELS, OpenAI added in Phase 12)
- Update ModelId type

**pricing.ts:**
No changes needed - already keyed by model ID string. Verify pricing lookup works with model IDs.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile.
Create a quick test in a scratch file that:
- Imports registry and anthropic provider (which registers itself)
- Confirms getProviderForModel("claude-sonnet-4-5-20250929") returns "anthropic"
- Confirms getProvider("anthropic", "test-key") returns an AnthropicProvider instance
  </verify>
  <done>
- AnthropicProvider implements AIProvider interface
- Factory registered via registerProviderFactory at module load
- Models organized with provider field
- `getProviderForModel("claude-sonnet-4-5-20250929")` returns "anthropic"
- `getProvider("anthropic", apiKey)` returns new AnthropicProvider instance
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Provider types are importable: `import type { AIProvider } from '~/lib/providers/types'`
3. Registry works: `getProviderForModel("claude-sonnet-4-5-20250929")` returns "anthropic"
4. Factory works: `getProvider("anthropic", "key")` returns AnthropicProvider instance
5. Models have provider field: `ANTHROPIC_MODELS[0].provider === "anthropic"`
</verification>

<success_criteria>
- Provider interface defined with chat(), validateKey(), getModels()
- AnthropicProvider class implements interface
- Provider registry uses factory pattern for on-demand instantiation
- Models organized by provider
- Existing code still compiles (may have import path changes)
</success_criteria>

<output>
After completion, create `.planning/phases/11-provider-abstraction/11-01-SUMMARY.md`
</output>
