---
phase: 18-decision-agent-routing
plan: 04
type: execute
wave: 3
depends_on: [18-01, 18-02, 18-03]
files_modified:
  - app/services/job-queue.server.ts
  - app/services/pipeline-executor.server.ts
autonomous: true

must_haves:
  truths:
    - "Pipeline execution follows edges based on runtime decisions"
    - "Decision nodes route to TRUE or FALSE edge based on parsed response"
    - "Execution supports cycles (revisiting earlier nodes)"
    - "Execution stops with error when max iterations reached"
    - "Step events emit nodeId for UI tracking"
  artifacts:
    - path: "app/services/pipeline-executor.server.ts"
      provides: "executeGraphPipeline function with decision routing"
      exports: ["executeGraphPipeline"]
    - path: "app/services/job-queue.server.ts"
      provides: "Updated worker using graph execution"
      contains: "executeGraphPipeline"
  key_links:
    - from: "app/services/job-queue.server.ts"
      to: "app/services/pipeline-executor.server.ts"
      via: "Calls executeGraphPipeline instead of executePipeline"
      pattern: "executeGraphPipeline"
    - from: "app/services/pipeline-executor.server.ts"
      to: "app/lib/decision-utils.ts"
      via: "Uses parseDecision for routing"
      pattern: "parseDecision"
---

<objective>
Rewrite pipeline executor from linear topological sort to graph traversal with decision routing.

Purpose: Enable conditional branching and cycles in pipeline execution.
Output: Graph-based executor that follows edges dynamically based on decision outcomes.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brendan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-decision-agent-routing/18-RESEARCH.md
@.planning/phases/18-decision-agent-routing/18-01-SUMMARY.md
@.planning/phases/18-decision-agent-routing/18-02-SUMMARY.md
@.planning/phases/18-decision-agent-routing/18-03-SUMMARY.md

Reference files:
@app/services/pipeline-executor.server.ts
@app/services/job-queue.server.ts
@app/db/schema/users.ts
@app/stores/pipeline-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graph-based executor function</name>
  <files>
    app/services/pipeline-executor.server.ts
  </files>
  <action>
    Add new function `executeGraphPipeline` to `app/services/pipeline-executor.server.ts`:

    1. Add import for parseDecision:
       ```typescript
       import { DECISION_SUFFIX, parseDecision } from "~/lib/decision-utils";
       ```

    2. Define new types for graph execution:
       ```typescript
       /**
        * Flow node data from pipeline canvas.
        */
       interface FlowNode {
         id: string;
         type: string;
         data: {
           agentId: string;
           agentName: string;
           agentInstructions?: string;
           isDecisionNode?: boolean;
           traitIds?: string[];
         };
       }

       /**
        * Flow edge from pipeline canvas.
        */
       interface FlowEdge {
         id: string;
         source: string;
         target: string;
         sourceHandle?: string; // "true" | "false" for decision nodes
       }

       /**
        * Parameters for graph-based pipeline execution.
        */
       export interface ExecuteGraphPipelineParams {
         runId: string;
         flowData: { nodes: FlowNode[]; edges: FlowEdge[] };
         initialInput: string;
         encryptedApiKey: string;
         model: string;
         maxIterations: number;
         agentDetails: Map<string, { instructions: string; traitContext?: string }>;
       }
       ```

    3. Add helper function to find entry node:
       ```typescript
       /**
        * Find the entry node (node with no incoming edges).
        */
       function findEntryNode(
         nodes: FlowNode[],
         edges: FlowEdge[]
       ): FlowNode | null {
         const targetIds = new Set(edges.map((e) => e.target));
         const entryNodes = nodes.filter((n) => !targetIds.has(n.id));
         return entryNodes[0] ?? null;
       }
       ```

    4. Implement `executeGraphPipeline`:
       ```typescript
       /**
        * Execute a pipeline using graph traversal with decision routing.
        * Supports branching based on decision node outcomes and cycles with iteration limits.
        */
       export async function executeGraphPipeline(
         params: ExecuteGraphPipelineParams
       ): Promise<void> {
         const {
           runId,
           flowData,
           initialInput,
           encryptedApiKey,
           model,
           maxIterations,
           agentDetails,
         } = params;

         const { nodes, edges } = flowData;

         // Get provider using abstraction layer
         const providerId = getProviderForModel(model);
         const decryptedKey = decrypt(encryptedApiKey);
         const provider = getProvider(providerId, decryptedKey);

         // Define tools for all steps
         const tools: ToolConfig[] = [
           { type: "web_search", maxUses: 5 },
           { type: "web_fetch", maxUses: 5 },
         ];

         // Find entry node
         const entryNode = findEntryNode(nodes, edges);
         if (!entryNode) {
           throw new Error("No entry node found in pipeline");
         }

         let iterations = 0;
         let currentNodeId: string | null = entryNode.id;
         let currentInput = initialInput;
         const usage = { totalInputTokens: 0, totalOutputTokens: 0 };
         const stepOutputs: Array<{
           nodeId: string;
           agentId: string;
           agentName: string;
           output: string;
           iteration: number;
         }> = [];

         try {
           // Update run status to running
           await db
             .update(pipelineRuns)
             .set({ status: "running" })
             .where(eq(pipelineRuns.id, runId));

           while (currentNodeId && iterations < maxIterations) {
             iterations++;

             const node = nodes.find((n) => n.id === currentNodeId);
             if (!node) break;

             const isDecision = node.data.isDecisionNode ?? false;
             const details = agentDetails.get(node.data.agentId);

             if (!details) {
               throw new Error(`Agent details not found for ${node.data.agentName}`);
             }

             // Build system prompt with decision suffix if needed
             const systemPrompt = buildSystemPrompt(
               details.instructions,
               details.traitContext,
               isDecision
             );

             // Emit step start event with nodeId for UI tracking
             runEmitter.emitRunEvent(runId, {
               type: "step_start",
               stepIndex: stepOutputs.length,
               agentName: node.data.agentName,
               nodeId: currentNodeId,
               iteration: iterations,
             });

             // Build user message
             const userMessage = currentInput.trim()
               ? currentInput
               : "Please proceed with your instructions.";

             const messages: ChatMessage[] = [
               { role: "system", content: systemPrompt },
               { role: "user", content: userMessage },
             ];

             // Execute agent
             const result = await provider.chat(messages, { model, tools });

             // Accumulate usage
             usage.totalInputTokens += result.usage.inputTokens;
             usage.totalOutputTokens += result.usage.outputTokens;

             let output = result.content;
             let nextNodeId: string | null = null;

             if (isDecision) {
               // Parse decision and route
               const { decision, cleanOutput, hadMarker } = parseDecision(output);
               output = cleanOutput;

               // Emit decision event for UI
               runEmitter.emitRunEvent(runId, {
                 type: "decision",
                 nodeId: currentNodeId,
                 decision,
                 hadMarker,
               });

               // Find edge matching the decision
               const sourceHandle = decision ? "true" : "false";
               const edge = edges.find(
                 (e) => e.source === currentNodeId && e.sourceHandle === sourceHandle
               );
               nextNodeId = edge?.target ?? null;
             } else {
               // Normal node: follow the single output edge
               const edge = edges.find((e) => e.source === currentNodeId);
               nextNodeId = edge?.target ?? null;
             }

             // Record step output
             stepOutputs.push({
               nodeId: currentNodeId,
               agentId: node.data.agentId,
               agentName: node.data.agentName,
               output,
               iteration: iterations,
             });

             // Emit step complete event
             runEmitter.emitRunEvent(runId, {
               type: "step_complete",
               stepIndex: stepOutputs.length - 1,
               output,
               nodeId: currentNodeId,
             });

             // Advance to next node
             currentInput = output;
             currentNodeId = nextNodeId;
           }

           // Check if we hit iteration limit
           if (iterations >= maxIterations && currentNodeId) {
             throw new Error(
               `Pipeline reached maximum iterations (${maxIterations}). This may indicate an infinite loop.`
             );
           }

           // Build artifact data from collected step outputs
           const artifactData: ArtifactOutput = {
             steps: stepOutputs.map((step, index) => ({
               agentId: step.agentId,
               agentName: step.agentName,
               output: step.output,
               stepOrder: index,
             })),
             finalOutput: currentInput,
           };

           // Calculate cost for this run
           const cost = calculateCost(model, usage.totalInputTokens, usage.totalOutputTokens);

           // All steps complete - update run with artifact data and metadata
           await db
             .update(pipelineRuns)
             .set({
               status: "completed",
               finalOutput: currentInput,
               artifactData,
               model,
               inputTokens: usage.totalInputTokens,
               outputTokens: usage.totalOutputTokens,
               cost: cost.toString(),
               completedAt: new Date(),
             })
             .where(eq(pipelineRuns.id, runId));

           // Emit pipeline complete event
           runEmitter.emitRunEvent(runId, {
             type: "pipeline_complete",
             finalOutput: currentInput,
             usage: {
               inputTokens: usage.totalInputTokens,
               outputTokens: usage.totalOutputTokens,
             },
             model,
             iterations,
           });
         } catch (error) {
           const errorMessage =
             error instanceof Error ? error.message : "Unknown error occurred";

           // Update run with error
           await db
             .update(pipelineRuns)
             .set({
               status: "failed",
               error: errorMessage,
               completedAt: new Date(),
             })
             .where(eq(pipelineRuns.id, runId));

           // Emit error event
           runEmitter.emitRunEvent(runId, {
             type: "error",
             message: errorMessage,
           });
         }
       }
       ```

    Note: Keep the existing `executePipeline` function for backward compatibility. The job
    queue will switch to using `executeGraphPipeline` in Task 2.
  </action>
  <verify>
    Run `npx tsc --noEmit` - no type errors
    File contains both executePipeline and executeGraphPipeline functions
  </verify>
  <done>
    Graph-based executor implemented with decision routing and iteration limits
  </done>
</task>

<task type="auto">
  <name>Task 2: Update job queue to use graph executor</name>
  <files>
    app/services/job-queue.server.ts
  </files>
  <action>
    Update `app/services/job-queue.server.ts` to use graph executor:

    1. Update import:
       ```typescript
       import { executeGraphPipeline, type ExecuteGraphPipelineParams } from "./pipeline-executor.server";
       ```

    2. Import users table:
       ```typescript
       import { db, pipelineRuns, pipelineRunSteps, agents, pipelines, apiKeys, agentTraits, users } from "~/db";
       ```

    3. In the worker function, after loading the pipeline, load user's maxIterations:
       ```typescript
       // Get user's max iterations setting
       const [user] = await db
         .select({ maxIterations: users.maxIterations })
         .from(users)
         .where(eq(users.id, userId));

       const maxIterations = user?.maxIterations ?? 10;
       ```

    4. Replace `buildStepsFromFlow` call and `executePipeline` call with new flow:
       ```typescript
       // Load agent details for all nodes in the flow
       const flowData = pipeline.flowData as { nodes: any[]; edges: any[] };
       const agentDetails = new Map<string, { instructions: string; traitContext?: string }>();
       const orphanedAgents: string[] = [];

       for (const node of flowData.nodes) {
         if (node.type !== "agent" && node.type !== "decision") continue;

         const agentId = node.data.agentId;
         const [agent] = await db.select().from(agents).where(eq(agents.id, agentId));

         if (!agent) {
           orphanedAgents.push(node.data.agentName ?? agentId);
           continue;
         }

         // Load pipeline-level trait context from node.data.traitIds
         const traitIds = node.data.traitIds ?? [];
         let traitContext: string | undefined;

         if (traitIds.length > 0) {
           const traits = await db.query.traits.findMany({
             where: (traits, { inArray }) => inArray(traits.id, traitIds),
             columns: { name: true, context: true },
           });
           traitContext = traits.length > 0
             ? traits.map((t) => `## ${t.name}\n\n${t.context}`).join("\n\n---\n\n")
             : undefined;
         }

         agentDetails.set(agentId, {
           instructions: agent.instructions,
           traitContext,
         });
       }

       // Fail fast if any agents have been deleted
       if (orphanedAgents.length > 0) {
         throw new Error(
           `Pipeline cannot run: ${orphanedAgents.length} agent(s) have been deleted: ${orphanedAgents.join(", ")}. Please update the pipeline.`
         );
       }

       // Determine model (use first agent's model if set)
       const firstNode = flowData.nodes.find((n) => n.type === "agent" || n.type === "decision");
       const firstAgentId = firstNode?.data.agentId;
       const [firstAgent] = firstAgentId
         ? await db.select().from(agents).where(eq(agents.id, firstAgentId))
         : [null];
       const pipelineModel = firstAgent?.model ?? defaultApiKey?.modelPreference ?? "claude-sonnet-4-5-20250929";

       // Get the correct API key for the model's provider
       const providerId = getProviderForModel(pipelineModel);
       const [apiKey] = await db
         .select()
         .from(apiKeys)
         .where(and(eq(apiKeys.userId, userId), eq(apiKeys.provider, providerId)));

       if (!apiKey) {
         await db
           .update(pipelineRuns)
           .set({ status: "failed", error: `${providerId} API key not configured. Please add your API key in Settings.` })
           .where(eq(pipelineRuns.id, runId));
         return;
       }

       // Execute pipeline using graph executor
       await executeGraphPipeline({
         runId,
         flowData,
         initialInput: input,
         encryptedApiKey: apiKey.encryptedKey,
         model: pipelineModel,
         maxIterations,
         agentDetails,
       });
       ```

    5. Remove the old `buildStepsFromFlow` function and related code (the function is no
       longer needed since we're using the flow data directly).

    6. Import traits table for loading pipeline-level traits:
       ```typescript
       import { db, pipelineRuns, pipelineRunSteps, agents, pipelines, apiKeys, agentTraits, users, traits } from "~/db";
       ```

       Note: Check the db/index.ts to see if traits is exported directly or needs to be
       imported differently (it may be exported from schema).
  </action>
  <verify>
    Run `npx tsc --noEmit` - no type errors
    Run `npm run dev` - app starts without errors
    Test: Create a simple pipeline and run it - should complete successfully
  </verify>
  <done>
    Job queue uses graph executor, loads maxIterations from user, supports decision routing
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `npm run dev` starts without errors
3. Simple pipeline (no decision nodes) still executes correctly
4. Pipeline with decision node routes based on TRUE/FALSE marker
5. Pipeline with cycle stops at max iterations
6. Step events include nodeId for UI tracking
</verification>

<success_criteria>
- Graph executor follows edges dynamically based on decisions
- Decision nodes parse DECISION marker and route to appropriate edge
- Cycles are supported (can revisit nodes)
- Max iterations limit enforced (default 10, from user setting)
- Existing pipelines without decision nodes continue to work
- Step events emit nodeId and iteration for UI tracking
</success_criteria>

<output>
After completion, create `.planning/phases/18-decision-agent-routing/18-04-SUMMARY.md`
</output>
