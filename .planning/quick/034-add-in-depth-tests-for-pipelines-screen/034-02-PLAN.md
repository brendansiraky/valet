---
phase: quick-034
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/hooks/queries/use-pipelines.test.ts
autonomous: true
---

<objective>
Test all pipeline mutation hooks (useRunPipeline, useSavePipeline, useDeletePipeline) with comprehensive coverage for success, error, and cache invalidation behavior.

Purpose: Ensure mutation hooks correctly send data to APIs, handle errors, and invalidate/update the query cache appropriately.
Output: Complete test coverage for pipeline mutation hooks.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@app/hooks/queries/use-pipelines.ts
@app/mocks/handlers.ts
@app/test-utils.tsx
@.claude/skills/react-query/references/testing.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mutation endpoint handlers to mocks</name>
  <files>app/mocks/handlers.ts</files>
  <action>
Add POST handlers for pipeline mutations to app/mocks/handlers.ts:

1. POST /api/pipeline/:pipelineId/run - For running pipelines:
   - Return { runId: "run-123" } on success
   - Accept FormData with "input" field

2. POST /api/pipelines - For save/create/delete operations:
   - Check "intent" field from FormData
   - For "create" intent: return { pipeline: { id: "new-pipeline-id", ...fields } }
   - For "update" intent: return { pipeline: { ...updated fields } }
   - For "delete" intent: return { success: true }

Follow existing handler patterns - use async handler if needed to parse request.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>All mutation endpoint handlers are defined in handlers.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for mutation hooks</name>
  <files>app/hooks/queries/use-pipelines.test.ts</files>
  <action>
Add mutation hook tests to app/hooks/queries/use-pipelines.test.ts (append to existing file or create if doesn't exist from plan 01):

1. Test useRunPipeline():
   - "runs pipeline and returns runId" - mutate with pipelineId and input, verify returns { runId }
   - "handles run error" - override handler to return error, verify isError state
   - "sends input as FormData" - use server.use to intercept and verify request body

2. Test useSavePipeline():
   - "creates new pipeline when isNew is true" - mutate with isNew: true, verify response
   - "updates existing pipeline when isNew is false" - mutate with isNew: false and id
   - "handles save error" - override handler to return error, verify isError
   - "does not invalidate pipelines cache on success" - verify no automatic refetch (this is intentional per comment in hook)

3. Test useDeletePipeline():
   - "deletes pipeline by id" - mutate with { id }, verify success
   - "invalidates pipelines cache on success" - seed cache with pipelines, delete one, verify cache is invalidated
   - "handles delete error" - override to return error, verify isError state

For cache invalidation tests:
- Use wrapper's queryClient to setQueryData before mutation
- After mutation success, check queryClient.getQueryState(['pipelines']) to verify invalidation

Use act() around mutate calls and await waitFor for state transitions.
  </action>
  <verify>npm test -- use-pipelines.test.ts shows all mutation tests passing</verify>
  <done>All mutation hook tests pass, covering success/error states and cache invalidation behavior</done>
</task>

</tasks>

<verification>
- npm run typecheck exits with code 0
- npm test -- use-pipelines.test.ts shows all tests passing
- Mutation tests verify both API calls and cache behavior
</verification>

<success_criteria>
- All three mutation hooks have test coverage
- Tests verify success and error states for each mutation
- Cache invalidation behavior is explicitly tested for useDeletePipeline
- No cache invalidation is verified for useSavePipeline (as per design)
</success_criteria>

<output>
After completion, report: number of mutation tests added, all passing, any issues encountered.
</output>
