---
phase: quick-034
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/hooks/queries/use-pipelines.test.ts
  - app/mocks/handlers.ts
autonomous: true
---

<objective>
Test all pipeline query hooks (usePipelines, usePipeline) with comprehensive coverage for loading, success, and error states.

Purpose: Ensure query hooks correctly fetch pipeline data, handle errors gracefully, and integrate properly with React Query.
Output: Complete test coverage for pipeline query hooks.
</objective>

<execution_context>
@/Users/brendan/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@app/hooks/queries/use-pipelines.ts
@app/mocks/handlers.ts
@app/test-utils.tsx
@.claude/skills/react-query/references/testing.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pipeline mock data to handlers</name>
  <files>app/mocks/handlers.ts</files>
  <action>
Add mock pipeline data and API handlers to app/mocks/handlers.ts following the existing pattern:

1. Add mockPipelinesData constant with sample pipeline list:
```typescript
export const mockPipelinesData = {
  pipelines: [
    { id: "pipeline-1", name: "Test Pipeline" },
    { id: "pipeline-2", name: "Another Pipeline" },
  ],
};

export const mockPipelineData = {
  pipeline: {
    id: "pipeline-1",
    name: "Test Pipeline",
    description: "A test pipeline for unit testing",
    flowData: { nodes: [], edges: [] },
  },
};
```

2. Add handlers for:
   - GET /api/pipelines - returns mockPipelinesData
   - GET /api/pipelines/:id - returns mockPipelineData
  </action>
  <verify>npm run typecheck passes with no errors</verify>
  <done>Mock data and handlers exist for pipeline list and individual pipeline endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for usePipelines and usePipeline hooks</name>
  <files>app/hooks/queries/use-pipelines.test.ts</files>
  <action>
Create app/hooks/queries/use-pipelines.test.ts with full test coverage following project patterns:

1. Import testing utilities:
   - vitest (describe, test, expect)
   - @testing-library/react (renderHook, waitFor)
   - msw (http, HttpResponse)
   - ~/mocks/server
   - ~/test-utils (createWrapper)
   - The hooks from ./use-pipelines

2. Test usePipelines():
   - "fetches and returns pipeline list" - verify data shape matches API response
   - "initially shows loading state" - check isLoading is true before data loads
   - "handles fetch error" - override handler to return 500, verify isError state
   - "returns empty array when no pipelines exist" - override handler to return { pipelines: [] }

3. Test usePipeline(id):
   - "fetches single pipeline by id" - verify data includes all fields (id, name, description, flowData)
   - "returns loading state while fetching" - check isLoading before success
   - "handles fetch error for single pipeline" - override to 500, verify isError
   - "is disabled when id is undefined" - pass undefined, verify query doesn't run (isLoading false, no data)
   - "is disabled when id is 'home'" - pass 'home', verify query doesn't run
   - "is disabled when id is 'new'" - pass 'new', verify query doesn't run

Use createWrapper() from test-utils for all renderHook calls.
Follow the pattern from references/testing.md - always await state transitions with waitFor.
  </action>
  <verify>npm test -- use-pipelines.test.ts passes all tests</verify>
  <done>All query hook tests pass, covering loading/success/error states and enabled/disabled behavior</done>
</task>

</tasks>

<verification>
- npm run typecheck exits with code 0
- npm test -- use-pipelines.test.ts shows all tests passing
- Test file follows co-location pattern (next to use-pipelines.ts)
</verification>

<success_criteria>
- Pipeline query hooks have complete test coverage
- Tests verify loading, success, and error states
- Tests verify the enabled/disabled logic for usePipeline
- All tests pass with no flakiness
</success_criteria>

<output>
After completion, report: number of tests added, all passing, any issues encountered.
</output>
